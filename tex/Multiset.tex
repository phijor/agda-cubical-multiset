\documentclass[runningheads]{llncs}

\usepackage[debug]{multiset}

\usepackage{bussproofs}

\usepackage{todonotes}

\begin{document}

\title{The Final Coalgebra of the Finite Bag Functor, Constructively}
\author{%
    Philipp Joram\orcidID{0000-0002-0448-7907} \and
    Niccolò Veltri\orcidID{0000-0002-7230-3436}%
}
%
\authorrunning{P. Joram and N. Veltri}
\institute{Department of Software Science, Tallinn University of Technology, Estonia}

\maketitle              % typeset the header of the contribution

\begin{abstract}

  Coalgebras for the finite bag functor are dynamical systems where the transition relation is resource-sensitive: the collection of reachable states records the number of ways in which each state can be reached. The final coalgebra of the finite bag functor is employed as a denotational domain for the evaluation of such dynamical systems. Its elements are non-wellfounded trees with finite unordered branching, depicting the evolution of systems starting from a given initial state.

  This paper is dedicated to the construction of the final coalgebra of the finite bag functor in homotopy type theory (HoTT). We first compare various equivalent definitions of finite bags employing higher inductive types, both as sets and as groupoids (in the sense of HoTT). We then analyze a few classical set-theoretic constructions of final coalgebras in our constructive setting. We show that, in the case of set-based definitions of finite bags, these constructions are either intrinsically classical, in the sense that they are equivalent to some weak form of excluded middle, or cannot be directly reproduced in HoTT without the assumption of classical principles. The final coalgebra can be safely constructed in HoTT only employing the groupoid-based definition of finite bags. We discuss generalizations of these constructions to more general analytic functors. We also show how Cubical Agda's coinductive types can be used to build the final coalgebra of the finite bag functor. 

\keywords{finite bags \and final coalgebra \and homotopy type theory.}
\end{abstract}

\setcounter{tocdepth}{1}
\tableofcontents

\section{Introduction}

\emph{Coalgebras} are functions of the form $c : S \to F S$, where $S$ is a set of states and $F$ is a functor specifying a certain class of collections of states \cite{Rutten2000,Jacobs2016}. For example, $F S$ could be lists over $S$, bags or subsets of $S$ (possibly with some cardinality restrictions), wellfounded trees with leaves or nodes in $S$, or probability distributions over $S$. The coalgebra $c$ describes the dynamics of a transition system or an automaton: to each state $s : S$, the function $c$ associates the collection of states $c \,s : F S$ that are reachable from $s$ in one step. The choice of collection functor $F$ is dictated by the specific flavour of non-determinism that is intrinsic in the transition relation. Does the order or multiplicity of reachable states matter? Is the choice of a new state probabilistic? Does the transition relation additionally depend on a set of labels, weights or actions?

The denotational semantics of a transition system $c : S \to F S$ is typically given in terms of the \emph{final coalgebra} $\nu F$ of the functor $F$, which  consists of non-wellfounded trees with branching specified by $F$. When $F$ is the list functor, each tree has a finite and ordered collection of subtrees. If $F$ is the finite bag functor, the order of subtrees does not matter, and if $F$ is the finite powerset functor, multiplicity of subtrees does not matter either. %Picking $F$ as the finite probability distribution functor, the trees correspond to
The interpretation of a state $s : S$ in $\nu F$ is the possibly-infinite tree obtained by ``running'' the coalgebra $c$ with $s$ as initial state. As such, it gives a complete description of the evolution of the system $c$ starting from state $s$.

The theory of dynamical systems as coalgebras \cite{Rutten2000,Jacobs2016}, and in particular the formal description of final coalgebras \cite{Barr1993,Adamek1995,Worrell2005} and the associated notion of bisimilarity and behavioural equivalence of states, is traditionally developed in a set-theoretic framework, with reasoning based on classical logic. In this work, we propose to study the theory of coalgebras in a framework based on constructive logic, more specifically in homotopy type theory (HoTT) \cite{HoTTBook}. The use of a constructive metatheory is beneficial for the development of \emph{formal denotational semantics} of dynamical systems and programming languages, often centered on the notions of final coalgebra and bisimilarity \cite{Turi1997}, in proof assistants based on variants of Martin-L{\"o}f type theory, such as Agda, Coq, Idris or Lean. The specific choice of HoTT is motivated by its expressivity and innovative features, higher inductive types (HITs) and the univalence principle, which are crucial ingredients for faithfully representing a variety of collection functors $F$ and reasoning up to equivalent presentations of $F$. 

Specific constructions of final coalgebras for a selection of functors, performed \emph{internally} in HoTT, already exist in the literature. Ahrens el al.~\cite{Ahrens2015} presented a construction of \emph{M-types}, i.e. final coalgebras of polynomial functors. They show that, for a polynomial functor $F$, the traditional set-theoretic construction of its M-type as the $\omega$-limit of the chain
\begin{equation}\label{eq:chain}
    1 \xleftarrow{!} {F 1}
      \xleftarrow{\Map{F} !} {F^2 1}
      \xleftarrow{\Map{F}^2 !} {F^3 1}
      \xleftarrow{\Map{F}^3 !}
      \cdots
\end{equation}
(with $1$ being the unit type and $!$ the unique map into $1$) can be ported without major complications to the setting of HoTT. Veltri \cite{Veltri2021} exhamined various constructions of the final coalgebra of the finite powerset functor, which is known to not be definable as an $\omega$-limit \cite{Adamek1995}. Worrell proposed a set-theoretic construction as a $(\omega+\omega)$-limit \cite{Worrell2005}, but Veltri showed that this cannot be ported to the constructive setting of HoTT: Worrell's $(\omega+\omega)$-limit is the final coalgebra of the finite powerset functor if and only if the \emph{lesser limited principle of omniscience} (\LLPO{}) holds, which is a constructive taboo \cite{Bridges1987}.


We extend this line of work by studying the final coalgebra of the \emph{finite bag functor}. This is an intermediate situation between finitary polynomial functors, such as the one delivering lists, and general finitary functors, such as the one delivering finite subsets. It also serves as the starting point for a constructive analysis of (final) coalgebras for the \emph{analytic functors} of Joyal \cite{Joyal1986}, arising in type theory from \emph{quotient containers} \cite{Abbott2004}, and generally encompassing many datatypes with symmetries associated to generalized species, such as finite bags, unordered pairs and cyclic lists \cite{Yorgey2010,Yorgey2014}.

Following the recent work of Choudhury and Fiore \cite{Choudhury2021}, we define and compare various implementations of the type of finite bags in HoTT. Choudhury and Fiore give two equivalent presentations of finite bags as HITs: as free commutative monoids and as lists modulo swapping of adjacent entries. We add an equivalent presentation of finite bags as an analytic functor: a finite bag $\FMSet X$ over a type $X$ is a pair of a natural number $n$ (its size) and an equivalence class of functions typed $\Fin n \to X$ picking an element of $X$ for each $k < n$. Two functions $f ,g :\Fin n \to X$ belong to the same equivalence class if there merely exists an equivalence $\sigma : \Fin n \to \Fin n$ such that $f \circ \sigma = g$. The type $\FMSet X$ is always a set (in the sense of HoTT, i.e. a type with at most one identification between any two terms), since it employs set-quotienting. Similarly, the HITs of Choudhury and Fiore are sets. Following \cite{Kock2012}, finite bags can alternatively be defined as a polynomial functor returning a groupoid (in the sense of HoTT, i.e. a type whose equality types are sets) instead of a set. In this case, a finite bag $\Bag X$ over $X$ is a pair consisting of a finite type $Y$ and a function from $Y$ to $X$. The set-based and the groupoid-based definitions of bags can be appropriately related via the set-truncation construction: $\SetTrunc{\Bag X} \simeq \FMSet X$.

We present 3 constructions of the final coalgebra of the finite bag functor:
\begin{enumerate}
\item Working with the set-based functor $\FMSet$, we try to replicate the classical set-theoretic construction as an $\omega$-limit of (\ref{eq:chain}) in our constructive setting. We show that this cannot be directly performed in HoTT without introducing some form of classical logic, an issue already spotted in the case of the finite powerset functor \cite{Veltri2021}. Formally, we show that $\FMSet$ weakly preserves the $\omega$-limit of (\ref{eq:chain}) (actually all $\omega$-limits if one assumes the axiom of countable choice), but strong preservation of this limit implies \LLPO{}.
\item The list functor admits a final coalgebra $\nu\List$ in HoTT \cite{Ahrens2015} and classically an appropriate quotient of the latter, by a relation $R$ identifying non-wellfounded trees which differ in the order of their subtrees, delivers the final coalgebra of the bag functor. This construction can be smoothly replicated as a \emph{strict} $\omega$-limit in the category of \emph{setoids} \cite{Barthe2003}. Problems arise when trying to port the latter from setoids to sets, effectively forming the set-quotient $\nu\List \mathbin{/_{\!2}} R$: we prove that the resulting type is a fixpoint for $\FMSet$, in the sense that $\FMSet (\nu\List \mathbin{/_{\!2}} R) \simeq \nu\List \mathbin{/_{\!2}} R$, but showing that this is the final coalgebra requires the assumption of the full axiom of choice. 
\item The groupoid-based polynomial functor $\Bag$ admits a final coalgebra $\nu\Bag$ as the $\omega$-limit of (\ref{eq:chain}), a result arising directly from the work of Ahrens et al.~\cite{Ahrens2015}. $\nu\Bag$ is a groupoid, not a set. One might wonder if the set-truncation $\SetTrunc{\nu\Bag}$ is a good candidate for the final $\FMSet$-coalgebra. We  show that it is a fixpoint of $\FMSet$, but showing that it is the final coalgebra seems to again require the axiom of choice. 
\end{enumerate}
Practically, the last two constructions, while not generally delivering the final coalgebra of the set-based bag functor, can still be used as denotational domains for resource-sensitive transition systems with a \emph{finite} set of states \cite{Frumin2018}: given a coalgebra $c : S \to \FMSet S$ where $S$ is (Bishop) finite, there exists a unique coalgebra morphism from $S$ to $\nu\List \mathbin{/_{\!2}} R$, and also from $S$ to $\SetTrunc{\nu\Bag}$.

We finally discuss generalizations of our constructions to other analytic functors. We also look at an alternative construction of the final $\FMSet$-coalgebra using Cubical Agda's primitive \emph{coinductive types} \cite{Vezzosi2019}. In Cubical Agda, HITs such as $\FMSet X$ can appear in the codomain of coinductive type destructors, which is intuitively justified by the treatment of HITs in Cubical Agda as inductive types with constructors possibly depending on interval variables \cite{Coquand2018,Cavallo2019}.

The material presented in the paper have been formalized in the Cubical Agda proof
assistant. The code is freely available at \url{https://github.com/phijor/agda-cubical-multiset}.

\section{Type Theory and Cubical Agda}

We work in homotopy type theory \cite{HoTTBook} and practically our formalization takes place in Cubical Agda \cite{Vezzosi2019}. In this section we recall some basic notions that are employed in our development.

Given a type $A$ and a type family $B$ on $A$, the associated dependent function type is $(x : A) \to B \, x$. Implicit arguments of dependent functions are enclosed in curly brackets. Basics inductive types include: unit type $1$, empty type $\bot$, Booleans values $\Bool$, natural numbers $ℕ$, finite prefixes of the naturals $\Fin n$, lists $\List A$, dependent pairs $\sum (x : A) \Where B \, x$, binary sum $A + B$ and products $A \times B$. We use standard names for their constructors. The unique function from a type $A$ into the unit type is called $! : A \to 1$. Membership in a list is $x \in xs$ and removal of an occurrence $m : x \in xs$ is $xs \setminus m$. Given an inductive type $T$, we write $\Elim{T}$ and $\Rec{T}$ for its dependent and non-dependent elimination  principles, respectively (we employ the same notation also for higher inductive types, introduced in the end of this section). The action on maps of a functor $F : \Type \to \Type$ is $\Map{F}$. Most of our constructions are universe-polymorphic, but for the sake of readibility in the paper we use only the two lowest universe of types, $\Type$ and $\Type_1$.

Given $x, y : A$, their definitional equality is denoted $x \DefEq y$ while propositional equality is $x = y$.
Following ``cubical terminology'', the latter is called the \emph{path type} between $x$ and $y$.
In Cubical Agda, the path type $x = y$ behaves similarly to a function type $\Interval \to A$, where $\Interval$ is a primitive interval type with endpoints $i_0$ and $i_1$.
An element $p : x = y$ is eliminated by application to an interval name $r : \Interval$, returning $p \, r : A$.
But unlike function types, this application can compute even when $p$ is unknown by using the endpoints $x$ and $y$: $p \,i_0$ reduces to $x$ and $p \,i_1$ reduces to $y$.
Path introduction is lambda abstraction $(\lambda i : \Interval.\,t) : x = y$, but it causes the extra requirement to match the endpoints: $t[i_0 / i]$ is judgementally equal to $x$ and $t[i_1 / i]$ is judgementally equal to  $y$. We write $\Refl\,x$ for the constant path (i.e. proof of reflexivity) in $x = x$ and $(\bullet)$ for sequentional composition of paths.

A function $f : A \to B$ is an \emph{equivalence} if it has contractible fibers, i.e. if the preimage of any element in $B$ under $f$ is a singleton type. Any function underlying a type isomorphism defines an equivalence. Writing $A \simeq B$ for the type of equivalences between $A$ and $B$, Voevodsky's \emph{univalence principle} states that the canonical function of type $A = B \to A \simeq B$ is an equivalence. This is a theorem in Cubical Agda. In particular, there is a function $\operatorname{ua} : A \simeq B \to A = B$ turning equivalences into path equalities. Univalence implies \emph{function extensionality}: pointwise equal functions are equal.

We recall the first instances of the hierarchy of \emph{homotopy levels}, and say that a type $A$ is:
\begin{itemize}
  \item ($n = 1$) a \emph{proposition}, if
    $\IsProp A \DefEq (a , b : A)\Where a = b$ is inhabited,
  \item ($n = 2$) a \emph{set}, if
    $\IsSet A \DefEq (a, b : A)\Where \IsProp \ (a = b)$ is inhabited,
  \item ($n = 3$) a \emph{groupoid}, if
    $\IsGpd A \DefEq (a, b : A)\Where \IsSet \ (a = b)$ is inhabited.
\end{itemize}
When mentioning \enquote{sets} or \enquote{groupoids}, we always refer to the definition above.

A \emph{higher inductive type} (HIT) is like an inductive type, but its constructors can build both its elements and its (higher) paths. HITs are primitively supported in Cubical Agda. We recall the definition of three basic HITs: propositional truncation, set truncation and the set quotient. 

The \emph{propositional truncation} $\PropTrunc{A}$ is the proposition associated to the type $A$, i.e. it unifies all the elements and (higher) paths of $A$. It is the HIT with constructors
\begin{center}
  \hspace*{\fill}
    \AxiomC{$a : A$}
    \UnaryInfC{
      $\PropTruncCon[a] : \PropTrunc{A}$
    }
    \DisplayProof
  \hfill
    \AxiomC{$x, y : \PropTrunc{A}$}
    \UnaryInfC{$\PropTruncSquash\,x\,y : x = y$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
We define the \emph{existential quantifier} $\exists (x : A) \Where B\, x \DefEq \PropTrunc{\sum (x : A) \Where B\,x}$, which records the mere existence of an element $x$ satisfying $B$.    

The \emph{set truncation} $\SetTrunc{A}$ is the set associated to the type $A$, i.e. it unifies all (higher) paths of $A$. It is the HIT with constructors
\begin{center}
  \hspace*{\fill}
    \AxiomC{$a : A$}
    \UnaryInfC{
      $\SetTruncCon[a] : \SetTrunc{A}$
    }
    \DisplayProof
  \hfill
    \AxiomC{$x, y : \SetTrunc{A}$}
    \AxiomC{$p, q : x = y$}
    \BinaryInfC{$\SetTruncSquash\,p\,q : p = q$}
    \DisplayProof
  \hspace*{\fill}
\end{center}

The \emph{set quotient} $\SetQuot[A][R]$ of a type $A$ by a (possibly proof-relevant) relation
$R : A \to A \to \Type$ is the HIT with constructors
\begin{center}
  \hspace*{\fill}
    \AxiomC{$a : A$}
    \UnaryInfC{
      $\SetQuotCon[a] : \SetQuot[A][R]$
    }
    \DisplayProof
  \hfill
    \AxiomC{$a, b : A$}
    \AxiomC{$r : R \,a\, b$}
    \BinaryInfC{$\operatorname{\mathsf{eq/}}_{\!\mathsf{2}}\,r : \SetQuotCon[a] = \SetQuotCon[b]$}
    \DisplayProof
  \hfill
    \AxiomC{$x, y : \SetQuot[A][R]$}
    \AxiomC{$p, q : x = y$}
    \BinaryInfC{$\SetQuotSquash\,p\,q : p = q$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
The term $\SetQuotCon[a]$ is the $R$-equivalence class of $a$, while the path constructor $\operatorname{\mathsf{eq/}}_{\!\mathsf{2}}$ states that $R$-related elements have path equal equivalence classes. The higher path constructor $\SetQuotSquash$ forces $\SetQuot[A][R]$ to be a set. A set-quotient $\SetQuot[A][R]$ is called \emph{definable} if the equivalence class constructor has a section, i.e. there is a representative-picking function $\rep: \SetQuot[A][R] \, \to A$ such that $\SetQuotCon[\rep\,x] = x$ for all $x : \SetQuot[A][R]$ \cite{Li2015}.

Other HITs are presented in the next section, where we also take a closer look at their elimination principles.



\section{The Finite Bag Functor in Sets}\label{sec:finite-bags-sets}

The action of the finite bag functor on a type $X$ can be encoded as higher inductive
types in various ways, three of which are presented here. 
The first is as the free commutative monoid, the second as lists modulo permutations,
%set-quotiented by an \emph{up to permutation}-relation,
the third as an analytic functor. These are all set-based definitions, in the sense that the type of finite bags is a set. Groupoid-based definitions are discussed in Section~\ref{sec:finite-bags-groupoids}.

\subsection{As the Free Commutative Monoid}

Given a type $X$, the \emph{free commutative monoid} on $X$
\cite{Choudhury2021} is the HIT $\M X$ induced by the following rules:
%\begin{itemize}
%  \item Point constructors:
    \begin{center}
      \hspace*{\fill}
        \AxiomC{$\vphantom{X}$}
        \UnaryInfC{$\Empty : \M{X}$}
        \DisplayProof
      \hfill
        \AxiomC{$x : X$}
        \UnaryInfC{$\Singl x : \M X$}
        \DisplayProof
      \hfill
        \hspace{10pt}
        \AxiomC{$xs, ys : \M X$}
        \UnaryInfC{$\Var{xs} \Union \Var{ys} : \M X$}
        \DisplayProof
      \hspace*{\fill}
%    \end{center}
 % \item Monoid axioms and commutativity:
      \\[6pt]
%    \begin{center}
      \hspace*{\fill}
        \AxiomC{$\Var{xs} : \M X$}
        \UnaryInfC{$\mathsf{unit} : \Empty \Union \Var{xs} = \Var{xs}$}
        \DisplayProof
      \hfill
        \AxiomC{$\Var{xs}, \Var{ys}, \Var{xs} : \M X$}
        \UnaryInfC{
          $\mathsf{assoc} : \Var{xs}\Union(\Var{ys}\Union\Var{zs}) = (\Var{xs}\Union\Var{ys})\Union\Var{zs}$
        }
        \DisplayProof
      \hspace*{\fill}
      \\[6pt]
      \hspace*{\fill}
        \AxiomC{$\Var{xs}, \Var{ys} : \M X$}
        \UnaryInfC{
          $\mathsf{comm} : \Var{xs}\Union\Var{ys} = \Var{ys}\Union\Var{xs}$
        }
        \DisplayProof
      \hspace*{\fill}
%    \end{center}
%  \item set truncation:
%    \begin{center}
%      \hspace*{\fill}
        \AxiomC{$\Var{xs}, \Var{ys} : \M X$}
        \AxiomC{$p, q : \Var{xs} = \Var{ys}$}
        \BinaryInfC{
          $\mathsf{squash}_{\M} \;p\;q : p = q$
        }
        \DisplayProof
      \hspace*{\fill}
    \end{center}
%\end{itemize}

The costructor $\Singl$ embeds $X$ into $\M X$, while $\Empty$ and $\Union$ are the unit and multiplication of the monoid. The path constructors express unitality of $\Empty$ wrt. $\Union$, associativity and commutativity of $\Union$, and the final higher path constructor forces $\M X$ to be a set.

In Cubical Agda, functions out of HITs like $\M X$ can be defined directly by pattern matching. But it is often useful to have elimination principles at hand that give more control on the shape of the proof obligations. For example, the non-dependent elimination principle of $\M X$ states that a function of type $\M X \to A$ is definable, provided that $A$ is a commutative monoid and there exists a function $\eta^* : X \to A$.
\begin{align*}
  \Rec{\M X} &: \{A : \Type\} → \IsSet A \\
    &→ (\varepsilon^* : A) \,(\eta^* : X → A) \, (({+}) : A → A → A) \\
    &→ (∀ a\Where \varepsilon^* + a = a) \\
    &→ (∀ a\, b\, c\Where a + (b + c) = (a + b) + c) \\
    &→ (∀ a\, b\Where a + b = b + a) \\
    &→ \M X → A
\end{align*}
$\M$ is a functor, with action on maps given by
\begin{align*}
  &\Map{M} : (f : X \to Y) \to \M X \to \M Y \\
  &\Map{M}\,f \DefEq \Rec{\M X}\;\mathsf{squash}_{\M}\;\Empty\;(\eta \circ f)\;(\Union)\;\mathsf{unit}\;\mathsf{assoc}\;\mathsf{comm}
\end{align*}

\subsection{As a Quotient of Lists}

Another standard definition of the type of finite multisets is as lists modulo permutations. The relation specifying the existence of a permutation between two lists can be given in multiple ways, here we mention two possibilities.

Given $xs, ys : \List X$, the relation $\Perm \,xs \,ys$ is generated by the rules:
\begin{center}
  \hspace*{\fill}
    \AxiomC{$\vphantom{X}$}
    \UnaryInfC{$\Perm \, xs\, xs$}
    \DisplayProof
  \hfill
    \AxiomC{$\Perm\, (xs \Append x \Cons y \Cons ys)\,zs$}
    \UnaryInfC{$\Perm\, (xs \Append y \Cons x \Cons ys)\,zs$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
In other words, $\Perm$ is the reflexive-transitive closure of the relation generated by pairs of lists of the form $xs \Append x \Cons y \Cons ys$ and $xs \Append x \Cons y \Cons ys$. This is a very intensional way of representing permutations of lists: a proof of $\Perm\, xs\, ys$ not only records where each entry in $xs$ is moved to in $ys$, but also how it is moved there. As such, $\Perm \, xs\,ys$ is not a proposition. 

Another way of specifying permutations is via a \emph{relation lifting}, often called a \emph{relator} \cite{Levy2011}. Given a relation $R$ on a type $X$, we inductively define a relation $\DRelator \, R$ on $\List X$, which intuitively states that each occurrence of an element $x$ in the first list is $R$-related to the occurrence of an element $y$ in the second list.
\begin{center}
  \hspace*{\fill}
    \AxiomC{$\vphantom{X}$}
    \UnaryInfC{$\DRelator\, R\; [\ ]\; ys$}
    \DisplayProof
  \hfill
    \AxiomC{$\exists (y : Y) \Where \sum (m : y \in ys) \Where R\;x\;y \times \DRelator\,R\;xs\;(ys \setminus m)$}
    \UnaryInfC{$\DRelator\, R\; (x \Cons xs)\;ys$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
The relation lifting of $R$ is the symmetric closure of $\DRelator\,R$, i.e. $\Relator\,R\;xs\;ys \DefEq \DRelator\,R\;xs\;ys \times \DRelator\,R\;ys\;xs$.
Because of the presence of a propositional trunctation in the premise of the 2nd rule, both $\DRelator\,R$ and $\Relator\,R$ are propositionally-valued. If $R$ is reflexive and transitive, than $\Relator\,R$ is an equivalence relation.

When $R$ is path equality on $X$, the type $\Relator\,(=)\;xs\;ys$ expresses the existence of a permutation connecting $xs$ and $ys$. In fact, there is a bi-implication between $\Perm\;xs\;ys$ and $\Relator\,(=)\;xs\;ys$. Therefore, we have two equivalent presentations of lists modulo permutations: $\SetQuot[\List X][\Perm]$ and $\SetQuot[\List X][\Relator\,(=)]$. They are also both equivalent to $\M X$.

\subsection{As an Analytic Functor}

Finally, we define the type of finite multisets over $X$ as an \emph{analytic functor}~\cite{Joyal1986}, which is provably equivalent to $\M X$, $\SetQuot[\List X][\Perm]$ and $\SetQuot[\List X][\DRelator\,(=)]$.
\begin{align*}
  \FMSet X
    \DefEq
    \sum (\Var{n} : ℕ) \Where
      \SetQuot[(\Fin \Var{n} \to X)][\SymAct \Var{n}]
\end{align*}
where $\sim$ is the propositionally-valued relation 
\begin{align*}
  \SymAct n \;v \;w &\mathrel{=_{\mathsf{df}}}
    ∃ (\sigma : \Fin n ≃ \Fin n) \Where
      v = w \circ \sigma
\end{align*}
In other words, an element of $\FMSet X$ is a pair of a natural numbers $n$ (the size of the multiset) and an equivalence class of functions $v : \Fin n \to X$ picking an element in $X$ for each index $k < n$. The relation $\SymAct n$ is the action of the symmetric group $\Fin n \simeq \Fin n$ on $n$-tuples of elements of $X$. By taking a different subgroup of the symmetric group one obtains different analytic functors, e.g. by restricting to cyclic permutations one gets cyclic lists. We write $\SymActSigma n$ for the non-propositionally truncated variant of $\SymAct n$. We write $v \sim w$ instead of $\SymAct n \;v \;w$ when $n$ is clear from context, and analogously $\SetQuot[(\Fin n \to X)][\sim]$ in place of $\SetQuot[(\Fin \Var{n} \to X)][\SymAct \Var{n}]$.





%% \begin{definition}
%%   The recursion principle for $\FMSet X$ is the function
%%   \begin{align*}
%%     \Rec{\FMSet}
%%       &: \{A : \Type\} → \IsSet{A} \\
%%       &→ (\Op{as} : \{n : ℕ\} → (v : \Fin n → X) → A) \\
%%       &→ (∀ n\Where (v, w : \Fin n → X) → v \sim_n w → \Op{as} v = \Op{as} w) \\
%%       &→ \FMSet X → A
%%   \end{align*}
%%   defined from the recursion principle of set-quotients.
%%   Similarly, we define the induction principle $\Op{elim}_{\FMSet}$ for
%%   a dependent type family $B : \FMSet X → \Type$ of sets.
%% \end{definition}

%\subsubsection{Finite Choice for Sets}

The proof of Theorem~\ref{thm:FMSetFixpointOfTrunc} employs the fact that $\FMSet$ is closed under set truncation.  The proof factors through the following lemma, stating that set truncation distributes over finite families of types.
\begin{lemma}\label{lem:FiniteChoice}
  For any $n : ℕ$ and type family $Y : \Fin n \to \Type$,
  there is an equivalence
  $
    \Op{box} :
    ((k : \Fin n) → \SetTrunc{\mathop{Y\/} k})
    ≃
    {\SetTrunc{(k : \Fin n) → \mathop{Y\/} k}}.
  $
\end{lemma}
\begin{proof}
  We sketch a proof for a constant type family $Y = (\lambda \Blank \Where X)$.
  The dependent case is analogous.
  The function underlying the equivalence is defined by induction on $n$.
  For $n = 0$ we have $\Fin 0 ≃ \bot$,
  so $\Op{box} \DefEq (\lambda \Blank\Where \SetTruncCon[\Elim{\bot}])$.
  In the inductive step, we lift the \enquote{cons} operation
  $
    (\Cons) : X → (\Fin n → X) → (\Fin{} (1 + n) → X)
  $
  on vectors to the set-truncation.
  A two-sided inverse $\Op{unbox} : \SetTrunc{\Fin n → X} → \Fin n → \SetTrunc{X}$ of $\Op{box}$ is given by $\Op{unbox} \bar{v}\, k \DefEq \Map{\SetTrunc{\Blank}} (\lambda v\Where v\, k)\, \bar{v}$.
  %By induction on $n$, we see that
  %\begin{align*}
  %  & \Op{unbox} : \SetTrunc{\Fin n → X} → \Fin n → \SetTrunc{X}\\
  %  &\Op{unbox} \bar{v}\, k \DefEq \Map{\SetTrunc{\Blank}} (\lambda v\Where v\, k)\, \bar{v}
  %\end{align*}
  %The proof uses the fact that $\Map{\SetTrunc{\Blank}}$ is functorial.
\end{proof}
%\begin{definition}
The equivalence of Lemma \ref{lem:FiniteChoice} allows to define a variant of the elimination principle $\Elim{\SetTrunc{\Blank}}$ which takes $\Fin n \to \SetTrunc{X}$ as input (a sort of ``finite choice'' principle for set truncation)
%taking The principle of finite choice can be defined in terms of $\Op{box}$:
  \begin{align*}
    \FinElim &: \{n : ℕ\}\, \{B : (\Fin n \to \SetTrunc{X}) \to \Type\} \to (\forall v\Where \IsSet (B\, v)) \\
      &\to ((w : \Fin n \to X) \to B\, (\SetTruncCon{} \circ w)) \\
      &\to (v : \Fin n \to \SetTrunc{X}) \to B\, v)
  \end{align*}
 % It is defined by applying $\mathsf{choice}$ to the term obtained from
 % set-truncation elimination on $\operatorname{box} v$.
  which furthermore comes with a (propositional) computational rule
  %\begin{align*}
    $\FinElimComp : (v : \Fin n → X)
      → \FinElim (\SetTruncCon{} \circ v) = \operatorname{\mathsf{choice}} v$.
  %\end{align*}
%\end{definition}

\begin{theorem}\label{thm:FMSetSetTruncInvariant}
  $\FMSet$ is invariant under set-truncation: $\FMSet \SetTrunc{X} ≃ \FMSet X$.
\end{theorem}
\begin{proof}
  The equivalence is obtained from an isomorphism.
  The right-to-left map is $\Map{\FMSet}\,\SetTruncCon{}$.
  For the left-to-right map, we use $\FinElim$ to define a function typed
$  %\[
    %\Op{requot} : ∀ \{n\}\Where
    (\Fin n → \SetTrunc{X})
    → \SetQuot[(\Fin n → X)][\sim]
  %\]
  $
  that turns set truncation into a set quotient, %and to prove that the latter preserves $(\sim)$.
  %By recursion on $\FMSet \SetTrunc{X}$,
  which is enough to obtain a function typed $\FMSet \SetTrunc{X} → \FMSet X$.
  That these maps are mutual inverses follows from $\FinElimComp$.
\end{proof}

\subsection{Definable Quotients and Sorting}\label{sec:Sorting}

The proof of Theorem~\ref{thm:InjPresSurjective} relies on the validity of two specific instances of the axiom of countable choice. We show here that these instances hold and therefore Theorem~\ref{thm:InjPresSurjective} is true without the need of postulating countable choice. This is achieved by showing that, whenever a type $X$ is endowed with a linear order $(<)$, then $\SetQuot[\List X][\Perm]$ is a definable set-quotient.

Remember that a relation $(<)$ is a \emph{linear order} when it is asymmetric, transitive, propositinally-valued and total, in the sense that the trichotomy $(x < y) + (x = y) + (y < x)$ holds for all $x,y:X$.
If $X$ has a linear order $(<)$, then lists over $X$ can be sorted wrt. $(<)$ via function $\sort : \List X \to \List X$ intuitively implementing the insertion-sort algorithm. We can show $\Perm \,xs\,(\sort\,xs)$. Sorting is independent of the positions of each entry in the input list, therefore via the recursion principle of set-quotients we obtain a function $\sortPerm : \SetQuot[\List X][\Perm] \to \List X$. It is not hard to show that $\sortPerm$ is a section of the equivalence class constructor, so $\SetQuot[\List X][\Perm]$ is a definable quotient.
The latter is equivalent to $\FMSet X$, which implies the following result.
\begin{proposition}\label{prop:ListPermDefQuot}
If $X$ is linearly-ordered, then $\SetQuot[(\Fin n \to X)][\sim]$ is a definable quotient for all $n : ℕ$.
\end{proposition}

Sorting also allows us to explicitly find a canonical permutation between any two related lists. Given $p : \Perm \,xs\,ys$, we can find another proof $\canonicalPerm \;p : \Perm\,xs\,ys$: there are permutations $\Perm\,xs\,(\sort\,xs)$ and $\Perm\,(\sort\,ys)\,ys$, and moreover the existence of the given permutation $p$ implies $\sort\,xs = \sort\,ys$. The function $\canonicalPerm$ is constant, since its definition never inspect the input permutation $p$. 
\begin{proposition}\label{prop:ListPermCanonicalPerm}
If $X$ is linearly-ordered, then for all $n : ℕ$ and $v,w : \Fin n \to X$ there exists a function typed $\SymAct n\; v\; w \to \SymActSigma n \;v \; w$ , i.e. the propositional truncation in $\SymAct n\; v\; w$ can be removed.
\end{proposition}

A linear order $(<)$ on $X$ can be extended to a linear order on $\List X$ via the \emph{lexicographic order}:
\begin{center}
  \hspace*{\fill}
    \AxiomC{$\vphantom{X}$}
    \UnaryInfC{$\Lex\, (<)\; [\ ]\; ys$}
    \DisplayProof
  \hfill
    \AxiomC{$x < y$}
    \UnaryInfC{$\Lex\,(<)\;(x \Cons xs) \;(y \Cons ys)$}
    \DisplayProof
  \hfill
    \AxiomC{$x = y$}
    \AxiomC{$\Lex\,(<)\;xs\;ys$}
    \BinaryInfC{$\Lex\,(<)\;(x \Cons xs) \;(y \Cons ys)$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
This can further be extended to a linear order on $\SetQuot[\List X][\Perm]$ as follows: $\LexPerm\,(<)\;x\;y \DefEq \Lex\,(<)\;(\sortPerm \,x)\;(\sortPerm \,y)$.
\begin{proposition}
If $X$ is linearly-ordered, then $\SetQuot[(\Fin n \to X)][\sim]$ is linearly-ordered for all $n : ℕ$.  
\end{proposition}

\section{The Final Coalgebra in Sets}\label{sec:final-coalgebra-sets}

We now turn to constructing the final coalgebra of the finite bag functor, given by one of the equivalent definitions in Section~\ref{sec:finite-bags-sets}. But first, a few basic definitions.

Given an functor $F : \Type \to \Type$, the types of \emph{coalgebras}
and \emph{coalgebra morphisms} between two coalgebras $(A,a)$ and
$(B,b)$ are 
\begin{align*}
  \Coalg\;F &\DefEq \sum (A : \Type) \Where A \to F A \\
  \CoalgMor\,F\,(A,a)\,(B,b) &\DefEq \sum (f : A \to B) \Where \forall x \Where b \,(f\,x) = \Map{F} f \,(a \,x)
\end{align*}
A coalgebra is \emph{final} if there exists a unique coalgebra morphism to any other coalgebra. This can be formalized by saying that there is a coalgebra $C : \Coalg\;F$ such that the type $\CoalgMor\;F\;C\;D$ is contractible for any other coalgebra $D$. These definitions are the same of Ahrens et al.~\cite{Ahrens2015}, which they only consider in the case of $F$ being a polynomial functor.

We now analyse two set-theoretic constructions of the final coalgebra for the finite bag functor: as an $\omega$-limit (Section~\ref{sec:final-limit-set}) and as a set-quotient of the final coalgebras of the $\List$ functor (Section~\ref{sec:final-quotient-set}).
%% Describe limits in general.
%% Maybe compare final coalgebras and corecursive algebras which are fixpoints.
%% \todo[inline]{%
%%   Mention what the type of final coalgebras is.
%%   Use contractibility for UP.
%% }
%% 
%% \subsection{$\omega$-Chains and Limits}
%% 
%% \begin{itemize}
%%   \item definition of chains (in type theory)
%%   \item define type of limits, mention universal property
%%   \item shifted limit
%%   \item mention that $\Op{pres}$ is given by the UP
%% \end{itemize}

\subsection{As an \ensuremath{\omega}-Limit}\label{sec:final-limit-set}

Consider the chain in (\ref{eq:chain}), with $F$ replaced by $\FMSet$. We formally define $\FMSet^n 1$ by recursion on $n$: $\FMSet^0 1 \DefEq 1$ and $\FMSet^{1 + n} 1 \DefEq \FMSet (\FMSet^1)$. Similarly we can define the iteration $\Map{\FMSet}^n\,!$.
In HoTT, the \emph{(homotopy) limit} of the chain is definable as
\[
\lim_{n} (\FMSet^n 1) \DefEq \sum (xs : \forall n \Where \FMSet^n 1) \Where \forall n \Where
\Map{\FMSet}^n\,!\,(xs_{1 + n}) = xs_n
\]
So an element of the limit consists of an element $xs_n : \FMSet^n 1$, for all $n : ℕ$, and a proof that restricting $xs_{1 + n}$ to $\FMSet^n 1$ via $\Map{\FMSet}^n\,!$ is equal to $xs_n$. The $n$-th projection from the limit is called $\ell_n : \lim_n (\FMSet^n 1) → \FMSet^n 1$. The limit is invariant wrt. shifting the chain by one position, i.e. there is an equivalence $\shift : \lim_{n} (\FMSet^n 1) \simeq \lim_{n} (\FMSet^{1 + n} 1)$.
The limit is a set, since all types in its diagram are sets.

In classical set theory, $\lim_{n} (\FMSet^n 1)$ can be proved to be the final coalgebra of $\FMSet$. The proof proceeds by first constructing a function $\Op{pres} : \FMSet \,(\lim_{n} (\FMSet^n 1)) \to \lim_{n} (\FMSet^{n+1} 1)$ via the universal property of the limit: the first component of $\Op{pres} \,s$ is $\lambda n \Where \Map{\FMSet}\,\ell_n \,s$. The function $\Op{pres}$ is then proved to be an equivalence, showing that $\FMSet$ preserves the $\omega$-limit. The composition of $\shift$ with the inverse $\Op{pres}^{-1}$ provides a coalgebra for $\lim_{n} (\FMSet^n 1)$. This can be proved to be final, again using the universal property of the limit.

Constructively, there are issues in proving that $\Op{pres}$ is an equivalence. We are able to show that it is surjective (actually more, a split epimorphism), but its injectivity is equivalent to the \emph{lesser limited principle of omniscience} (\LLPO{}) \cite[{Ch.\@ 1}]{Bridges1987}. The latter is a weak version of the law of the excluded middle, and it is not provable from intuitionistic axioms alone.  It states that, given an infinite stream of boolean
values that yields $\True$ in at most one position, one can decide
whether all even or all odd positions are $\False$.

\begin{theorem}\label{thm:InjPresSurjective}
 The function $\Op{pres}$ is surjective.
\end{theorem}

Both injectivity of $\Op{pres}$ and \LLPO{} are propositions, so it is sufficient to show that there is a bi-implication between them. But first a useful lemma.

\begin{lemma}\label{lem:DiagLimCaseAnalysis}
  For any $x, y_1, y_2 : \lim_n(\FMSet^n 1)$ and $\Var{ys} : ℕ → \lim_n(\FMSet^n 1)$,
  such that $∀ n\Where \ell_n\,x = \ell_n\,(\Var{ys}\,n)$, if some $n$ we have
  $\Var{ys}\,n = y_1$ and $\Var{ys}\,(1+n) = y_2$, then $\Map{\FMSet}^n\,!\, (\ell_{1+n}\,y_1) = \ell_n\,y_2$.
\end{lemma}
\begin{proof}
  We have the following sequence of equalities:
  \begin{align*}
    \Map{\FMSet}^n\,!\, (\ell_{1+n}\,y_1)
      &= \ell_n\,y_1 
      = \ell_n\,(\Var{ys}\,n) 
      = \ell_n \,x \\
      &= \Map{\FMSet}^n\,!\, (\ell_{1+n}\,x) 
      = \Map{\FMSet}^n\,!\, (\ell_{1+n}\,(\Var{ys}\,(1+n))) \\
      &= \Map{\FMSet}^n\,!\,(\ell_{1 + n} \,y_2) 
      = \ell_n \,y_2
  \end{align*}
\end{proof}

\begin{theorem}\label{lem:InjPresImpliesComplete}
  If $\Op{pres}$ is injective, then \LLPO{} holds.
\end{theorem}
\begin{proof}
  In this proof we use $\M$ instead of $\FMSet$. The statement of the theorem holds since $\M X$ is equivalent to $\FMSet$. 
  It is sufficent to show that the injectivity of $\Op{pres}$ implies that the following type is inhabited:
  \begin{equation}\label{eq:compl}
    \def\arraystretch{1.2}
    \begin{array}{l}
   \{x, y_1, y_2 : \lim_n(\M^n 1)\} \;(ys : ℕ \to \lim_n(\M^n 1)) \\
  \hspace{.5cm} \to (\Op{split} : \forall n \Where ys\;n = y_1 +  ys\;n = y_2) (\Op{diag} : \forall n \Where \ell_n \;x = \ell_n \;(ys\;n)) \\
  \hspace{.5cm} \to \PropTrunc{x = y_1 + x = y_2}
    \end{array}
  \end{equation}
  This is a form of \emph{completeness} of two-element subsets of the $\omega$-limit~\cite{Mandelkern1988} which is known to imply \LLPO{}~\cite[{Theorem~7}]{Veltri2021}.
  
%  Given an element $ : L_{\M}$\todo{We're implicitly working with the HIT-definition here},
%  denote by $\ell_n : L_{\M} → \M^n 1$ the projection maps out of the limit.

  To prove completeness, assume $x, y_1, y_2, ys, \Op{split}$ and $\Op{diag}$ as in (\ref{eq:compl}).
  %:  \lim_n(\M^n 1)$, $\Var{ys} : ℕ →  \lim_n(\M^n 1)$,
  %$\Op{split} : ∀ n\Where (\Var{ys}\,n = y_1) \mathrel{+} (\Var{ys} \,n = y_2)$
  %and $\Op{diag} : ∀ n\Where \ell_n \,x = \ell_n (\Var{ys}\,n)$.
  %The goal is to show $\PropTruncCon[x = y_1 \mathrel{+} x = y_2]$.
  Using $\Op{split}$, define the complement of $\Var{ys}$ as $\overline{\Var{ys}}\,n\DefEq y_2$ is $\Var{ys}\, n = y_1$ and $\overline{\Var{ys}}\,n\DefEq y_1$ if $\Var{ys}\,n = y_2$.
%%   \[
%%     \overline{\Var{ys}}\,n\DefEq
%%       \begin{cases}
%%         y_2 & \text{if}~\Var{ys}\, n = y_1 \\
%%         y_1 & \text{if}~\Var{ys}\,n = y_2
%%       \end{cases}
%%   \]
  The diagonal of $\overline{\Var{ys}}$ also has the limit-property,
  i.e.
  \begin{equation}\label{step:IsLimYsComplement}
    ∀ n\Where
    \Map{\M}^n\,!\, (\ell_{1 + n} \,(\overline{\Var{ys}}\, (1+n))) = \ell_n \,(\overline{\Var{ys}}\,n)
  \end{equation}
    %  \Step{step:IsLimYsComplement}$$
  For this, fix $n$ and check the four cases generated by inspecting $\Op{split} n$
  and $\Op{split}{} (1+n)$.
  In one case, (\ref{step:IsLimYsComplement}) reduces to the limit-property of $y_1$,
  in another to that of $y_2$ and in the remaining cases to \cref{lem:DiagLimCaseAnalysis}.
  Call  $\overline{x} : \lim_n(\M^n 1)$ the element of the limit such that $\ell_n \,\overline{x} \DefEq \ell_n\,(\overline{ys}\,n)$.

  Write $\{x, y\} \DefEq \eta\, x \oplus \eta\, y$ for the two-element bag comprising of $x$ and $y$. For all $n$, we know that
  %\begin{align}\Step{step:ppc}
    $\{\Var{ys}\,n, \overline{\Var{ys}}\,n\} = \{y_1, y_2\}$
  %\end{align}
  either by $\Op{refl}$ or $\Op{\oplus comm}$, depending on $\Op{split} n$.
  Using the latter equality, the definition of $\Op{pres}$ and the assumption $\Op{diag}$, we can form the following sequence of paths:%\todo{better wording}
  \begin{align*}
    \ell_n\,(\Op{pres} \{x, \overline{x}\})
      &= \{\ell_n \,x , \ell_n \,\overline{x}\}
      = \{\ell_n \,(\Var{ys}\,n) , \ell_n\,(\overline{\Var{ys}} \,n)\}\\
      &= \ell_n \, (\Op{pres} \{\Var{ys}\,n , \overline{\Var{ys}}\,n\}) 
      = \ell_n \, (\Op{pres} \{y_1 , y_2\})
  \end{align*}
  which implies that $\Op{pres}\{x, \overline{x}\} = \Op{pres}\{y_1, y_2\}$.
  From the injectivity of $\Op{pres}$ it follows that $\{x, \overline{x}\} = \{y_1, y_2\}$, which also implies that (merely) $x = y_1$ or $x = y_2$.
\end{proof}

\begin{theorem}\label{lem:LLPOImpliesPresInj}
  \LLPO{} implies the injectivity of $\Op{pres}$.
\end{theorem}
%\begin{proof}
%  \todo[inline]{Prove it.}
%\end{proof}
For the proof, which employs the functor $F X \DefEq \SetQuot[\List X][\Relator\,(=)]$ instead of $\FMSet$, we refer the reader to our Agda formalization.  The proof is similar to the one of a related result in \cite{Veltri2021}: the injectivity of $\Op{pres} : \Op{Pfin} \,(\lim_{n} (\Op{Pfin}^n 1)) \to \lim_{n} (\Op{Pfin}^{n+1} 1)$, where $\Op{Pfin}$ is the finite powerset functor, is derivable from \LLPO{} and the axiom of countable choice. It turns out that countable choice is not needed, neither in \cref{lem:LLPOImpliesPresInj} nor in the similar result for the finite powerset functor.


\subsection{As a Quotient of the Final $\List$-Coalgebra}\label{sec:final-quotient-set}

It is known that the limit $\lim_n (\List^n 1)$ is the final coalgebra of the list functor in HoTT~\cite{Ahrens2015}. Using the relation lifting $\Relator$, it is possible to construct a relation on $\lim_n (\List^n 1)$ so that the resulting setoid is the final coalgebra of the setoid-functor $\Op{FMSetoid}(X,R) \DefEq (\List X,\Relator\,R)$ in the category of setoids \cite{Barthe2003}. The desired relation on $\lim_n (\List^n 1)$ is obtained as the $\omega$-limit of the chain
\begin{equation}\label{eq:chain-rel}
    \Op{Tot} \xleftarrow{} {\Relator\,\Op{Tot}}
      \xleftarrow{} {\Relator^2\,\Op{Tot}}
      \xleftarrow{} {\Relator^3\,\Op{Tot}}
      \xleftarrow{} %{\Map{F}^3 !}
      \cdots
\end{equation}
in the category of relations, where $\Op(Tot)$ is the total relation on the unit type $1$. The chain in (\ref{eq:chain-rel}) lives above the chain in (\ref{eq:chain}) with $F \DefEq \List$.
\begin{theorem}\label{thm:final-setoids}
The setoid $(\lim_n(\List^n 1),\lim_n(\Relator^n 1))$ has a $\Op{FMSetoid}$-coalgebra structure which is final in the category of setoids.
\end{theorem}
The proof is similar to the one for the finite powerset functor in \cite[{Theorem~1}]{Veltri2021}.

Similarly to the case of the finite powerset, set-quotienting $\lim_n(\List^n 1)$ by the relation $\lim_n(\Relator^n 1)$ does not give the final coalgebra for the finite bag functor in sets. We can show that the resulting quotient is a fixpoint, and in particular a coalgebra. But the proof of finality requires the full axiom of choice. 
\begin{theorem}\label{thm:fixpoint-quotient}
  For all $X : \Type$, we have $\FMSet(\SetQuot[\lim_n(\List^n 1)][\lim_n(\Relator^n 1)]) \simeq \SetQuot[\lim_n(\List^n 1)][\lim_n(\Relator^n 1)]$.
\end{theorem}
\begin{theorem}\label{thm:final-quotient}
  Assuming the axiom of choice, $\SetQuot[\lim_n(\List^n 1)][\lim_n(\Relator^n 1)]$ is the final coalgebra of $\FMSet$ in sets.
\end{theorem}
Both proofs, which employs the functor $F X \DefEq \SetQuot[\List X][\Relator\,(=)]$ instead of $\FMSet$, are analogous to related ones for the finite powerset functor in \cite{Veltri2021}.
Why is the axiom of choice needed in \cref{thm:final-quotient}? Intuitively, the construction of a coalgebra morphism from a given coalgebra $c : X \to \SetQuot[\List X][\Relator\,(=)]$ can invoke $c$ an arbitrarily large number of times. Since we are given no information on the
cardinality of $X$, each application of $c$ may happen on a different
input $x: X$. This implies that generally the recursion principle of
set quotients would need to be employed the same large number of times,
and this could only be achieved by assuming the full axiom of choice.


While not delivering the final coalgebra of $\FMSet$ without extra classical assumptions, the quotient $\SetQuot[\lim_n(\List^n 1)][\lim_n(\Relator^n 1)]$ can still be used as a denotational domain for transition systems with a finite set of states: given a coalgebra $c : S \to \FMSet S$ where $S$ is (Bishop) finite, we are able to construct a unique coalgebra morphism from $S$ to $\SetQuot[\lim_n(\List^n 1)][\lim_n(\Relator^n 1)]$.

\section{The Finite Bag Functor in Groupoids}\label{sec:finite-bags-groupoids}

The results of Section~\ref{sec:final-coalgebra-sets} are evidence that the set-based definitions of finite bags from Section~\ref{sec:finite-bags-sets} are not fit for a fully constructive construction of the final coalgebra. In this section we start looking at groupoid-based definition and, following the ideas of Kock~\cite{Kock2012} and Finster et al.~\cite{Finster2021},  argue that the correct perspective on finite bags in HoTT is to define them as groupoids instead of sets, particularly for the goal of final semantics.
The rationale is that identifications of bags are permutations, and these should inherently be treated as \emph{data}.
Instead of viewing bags as quotients of lists, thereby \enquote{forgetting} about the permutations,
we define a type of lists with \enquote{more identifications}.
Since all constructions based on this type have to be homotopy coherent,
they will automatically respect the extra data,
making them invariant under permutation for free.
We define a type family $\Bag : \Type → \Type$ of finite bags in groupoids,
and substantiate the previous claims by first showing that its set-truncation is equivalent to $\FMSet$ (\cref{thm:FMSetOfFMGpdTrunc}),
and later by constructing its final coalgebra in a straighforward way %(\cref{ssec:FMGpdLim},
(\cref{thm:FMGpdLim}).

First, recall one way of defining finite sets in HoTT \cite{Frumin2018}.
%\begin{definition}
  A type $Y$ is called \emph{(Bishop-) finite} if
  $
    \Op{isFinSet} Y \DefEq
      \sum (n : ℕ)\Where \PropTrunc{Y ≃ \Fin n}
  $
  holds,
  and we denote the collection of such types by
  $
    \Op{FinSet} \DefEq
      \sum (Y : \Type)\Where \Op{isFinSet} Y.
  $
  The underlying type of a $\FinSet$ is accessed via the first projection $\langle\Blank\rangle : \FinSet → \Type$.
%\end{definition}

It is easy to show that $\Op{isFinSet}$ is a proposition and that any type satisfying the predicate is a set.
It follows that $\Op{FinSet}$ forms a groupoid.
Note that $\Op{FinSet}$ is a \emph{large} type, i.e. $\Op{FinSet} : \Type_1$.
%it lives in the successor universe of the types that it ranges over.
From this, we can define a \enquote{tote} $\Tote : \Type → \Type1$ (``tote'' in the sense of a ``large bag'') as
%, which we think of as a finite collection of elememts in $X$:
%\begin{definition}
%  A large type, $\Tote : \Type_\ell → \Type_{\ell + 1}$:
  \begin{align*}
    \Tote X
      \mathbin{=_{\mathrm{df}}}
      \sum\,(\Var{B} : \Op{FinSet})\Where \langle B \rangle \to X,
  \end{align*}
%\end{definition}
Elements of $\Tote X$ are pairs consisting of a finite set $B$ and a function from (the type underlying) $B$ to $X$ which picks the elements in the tote. The univalence principle implies that the path type $(B,v) = (C,W)$ in $\Tote X$ is equivalent to the type of dependent pairs consisting of an equivalence $\sigma : \langle B \rangle \simeq \langle C\rangle$ and a path $v = w \circ \sigma$.
This indicates that $\Tote X$ is not a set, in general it is at least a groupoid.
\begin{proposition}
  If $X$ is a groupoid, then $\Tote X$ is a groupoid.
\end{proposition}
\begin{proof}
  Since $X$ is a groupoid, the function type $\langle B \rangle → X$ is a groupoid
  for any $B : \FinSet$.
  $\FinSet$ is also a groupoid, so the entire $\Sigma$-type is a groupoid.
\end{proof}
$\Tote X$ differs from $\FMSet X$ in that path equality in the former records the permutations between the (finite sets representing) sizes of the bags, while the second only cares about the mere existence of a permutation. Nonetheless, the two definitions become equivalent when we set-truncate the type of totes.
\begin{theorem}\label{thm:FMSetOfFMGpdTrunc}
  For any type $X$, $\SetTrunc{\Tote X} ≃ \FMSet X$.
\end{theorem}
\begin{proof}
  The proof proceeds by constructing an isomorphism $\FMSet X \cong \SetTrunc{\Tote X}$.
  The forward direction is unproblematic, while the inverse function has to be carefully defined with the homotopy levels of the involved types in mind.

  A function $\ToTote : \FMSet X → \SetTrunc{\Tote X}$ can be defined by invoking $\Rec{\FMSet}$, so it is enough to give a function
  $f : \forall \{\Var{n}\}\Where (\Fin \Var{n} → X) → \SetTrunc{\Tote X}$
  and show that it respects $(\sim)$.
  Take $f(v) \DefEq \SetTruncCon[(\Fin \Var{n} , v)]$, since $\Fin \Var{n}$ is obviously a finite set.
  To prove that $v \sim w$ implies $f(v) = f(w)$, notice that the conclusion is a proposition,
  thus by invoking $\Rec{\PropTrunc{\Blank}}$ we can assume given a permutation $\sigma$ such that $r : v = w \circ \sigma$.
  By univalence, $\Op{ua} \sigma : \Fin \Var{n} = \Fin \Var{n}$,
  and transporting $r$ along this path yields
  $
    p : (\Fin\Var{n} , v) = (\Fin\Var{n}, w)
  $.
  Then $\Op{cong} \SetTruncCon\, p : f(v) = f(w)$ as desired.

  In the other direction, define $\ToFMSet : \SetTrunc{\Tote X} → \FMSet X$
  by invoking $\Rec{\SetTrunc{\Blank}}$, so it is enough to provide $g : \Tote{X} → \FMSet X$. %which is given as $g\, ((B, \Var{n}, e), v) \DefEq (\Var{n} , g')$.
  Assume given a finite set $B$ of size $\Var{n}$ with $e : \PropTrunc{B ≃ \Fin\Var{n}}$ and $v : B → X$. We would like to return something in $\SetQuot[(\Fin\Var{n} → X)][\mathord{\sim}]$ by recursion on $e$, but this cannot work since the return type is a set.
%  We would like to use a composition $\Fin\Var{n} → Y → X$ to find
%  $g' : \SetQuot[(\Fin\Var{n} → X)][\mathord{\sim}]$,
%  but one cannot do so because $e$ is propositionally truncated.
%  Using induction directly on $e$ cannot work, since $g'$ lives in a set.
  We can however employ a different recursion principle of propositional truncation \cite[{Corollary~2}]{Capriotti2015}, which allows to define a function into a set provided that the function is \emph{(weakly) constant} in the sense of \cite{Kraus2017}. Define  
%  \begin{align*}
    $g' : (B ≃ \Fin\Var{n}) → \SetQuot[(\Fin\Var{n} → X)][\mathord{\sim}]$ as $g'\, \alpha \DefEq \SetQuotCon[v \circ \alpha]$, which can be proved to be constant and therefore well-defined. We can then take $g\, ((B, \Var{n}, e), v) \DefEq (\Var{n} , g'\,e)$.
  %\end{align*}
  Proving $\ToFMSet \circ \ToTote = \Op{id}$ is straightforward.
  Proving $\ToTote \circ \ToFMSet = \Op{id}$ reduces to showing that $v \circ \alpha \sim v$ for any $v : B → X$ and $\alpha : \Fin n ≃ B$, which is also direct.
\end{proof}

As $\Tote X$ is a large type, it is unsuitable for iteration, as the assignment $(\lambda n\Where \Tote^n \mathsf{1})$
of $n$-fold applications of the family is not well-typed.
%typeable in a universe of bounded size.
Following \cite{Finster2021}, we introduce an equivalent but small definition $\Bij$ of the type of finite sets $\Op{FinSet}$ that avoids this issue.
  \begin{center}
    \small
    \hspace*{\fill}
      \AxiomC{$n : \N$}
      \UnaryInfC{
        $\Obj n : \Bij$
      }
      \DisplayProof
    \hfill
      \AxiomC{$m, n : \N$}
      \AxiomC{$\alpha : \Fin m ≃ \Fin n$}
      \BinaryInfC{$\Hom : \Obj m = \Obj n$}
      \DisplayProof
    \hfill
      \AxiomC{$n : \N$}
      \UnaryInfC{$\Hom (\mathsf{id}) = \Refl\,(\Obj n)$}
      \DisplayProof
    \hspace*{\fill}
    \\[1em]
    \hspace*{\fill}
      \AxiomC{$m, n, o : \N$}
      \AxiomC{$\alpha : \Fin m ≃ \Fin n$}
      \AxiomC{$\beta : \Fin n ≃ \Fin o$}
      \TrinaryInfC{$\Hom(\beta \circ \alpha) = \Hom \alpha \bullet \Hom \beta$}
      \DisplayProof
      \hspace*{\fill}
        \AxiomC{$\vphantom{X}$}
        \UnaryInfC{$\IsGpd \;\Bij$}
        \DisplayProof
    \hspace*{\fill}
  \end{center}
  %Here, $\operatorname{id}$ is the identity-equivalence, $(\circ)$ composition of equivalences,
  There is an equivalence $\Bij \simeq \Op{FinSet}$. In particular, one can extract a type $\langle x \rangle : \Type$ from each $x : \Bij$.

  A small type of finite bags in groupoids is defined replacing $\Op{FinSet}$ with $\Bij$.
%\begin{definition}\label{def:Bag}
%  A small type:
  \begin{align*}
    \Bag X
      \mathbin{=_{\mathrm{df}}}
      \sum\,\Var{x} : \operatorname{\mathsf{Bij}}\Where
        \langle x \rangle \to X,
  \end{align*}
 We abbreviate $\BagCon{v} \DefEq (x, v) : \Bag X$ if $x : \Bij$ can be inferred from context.
%\end{definition}
%\paragraph{Comparing $\Op{List}$ and $\Bag$}\todo{Fit this comparison in somewhere}
 Notice that $\Bag$ is the \emph{polynomial functor} associated to the container with $\Bij$ and $\langle x \rangle$ as positions at shape $x$. This can be seen as a \enquote{higher, more informative} variant of the list functor, which has $ℕ$ as shapes and $\Fin n$ as positions at shape $n$, a statement substantiated by Theorem \ref{thm:FMSetOfFMGpdTrunc}.
% , in a way analogous to $\Op{List}$:
%Given a type $A$ and a family $B$ over it, they both match ${\sum (a : A)\Where B(a) → X}$:
%we have $A = ℕ$ and $B = \Fin$ for $\Op{List}$,
%and $A = \Bij$ and $B = \BagCon{\Blank}$ for $\Bag$.
%In particular, $\SetTrunc{\Bij} ≃ ℕ$.

\section{The Final Coalgebra in Groupoids}


%\subsection{Final Coalgebras as an $\omega$-Limit in Groupoids}\label{ssec:FMGpdLim}

\begin{theorem}\label{thm:FMGpdLim}
  Let $L_{\Bag} \DefEq \lim_{n < \omega} \Bag^n 1$.
  The limit-preservation map $\operatorname{pres}$ is an equivalence of groupoids.
  In particular, the limit $L_{\Bag}$ is a fixpoint of $\Bag$ and its final coalgebra.
\end{theorem}

\subsection{Truncating the Groupoid Construction}

Compare the set-truncation of the groupoid construction
and the set-level definition.

\begin{theorem}\label{thm:FMSetFixpointOfTrunc}
  The set-truncation of $\Lim{\Bag}$ is a fixpoint of $\FMSet$, i.e.\@
  there is an equivalence $\FMSet \SetTrunc{\Lim{\Bag}} ≃ \SetTrunc{\Lim{\Bag}}$.
\end{theorem}
\begin{proof}
  The equivalence is obtained from the composition
  \begin{align}
    \FMSet \SetTrunc{\Lim{\Bag}}
      &≃ \FMSet \Lim{\Bag}          \Step{thm:FMSetFixpointOfTrunc:step1} \\
      &≃ \SetTrunc{\Bag \Lim{\Bag}} \Step{thm:FMSetFixpointOfTrunc:step2} \\
      &≃ \SetTrunc{\Lim{\Bag}}      \Step{thm:FMSetFixpointOfTrunc:step3}
  \end{align}
  where \eqref{thm:FMSetFixpointOfTrunc:step1} is invariance of $\FMSet$ under set-truncation
  (\cref{thm:FMSetSetTruncInvariant}),
  \cref{thm:FMSetFixpointOfTrunc:step2} is \cref{thm:FMSetOfFMGpdTrunc}
  and \eqref{thm:FMSetFixpointOfTrunc:step3} follows since $\Lim{\Bag}$ is a limit (\cref{thm:FMGpdLim}).
\end{proof}

Note that the above fixpoint is not necessarily the \emph{largest} fixpoint.
\todo[inline,caption={Choice for largest fixpoint}]{%
  \emph{(Unproven)}
  Only assuming the (full) axiom of choice this is the case, i.e.\@ yields a final coalgebra.
  }

\section{Discussion: Alternatives}
\subsection{Outlook: Generalization to Analytic Functors}

\begin{itemize}
    \item Hint at a definition of analytic functors using
        the above definitions (pick a subgroupoid of Bij etc.)
    \item Question:
        Does this definition \emph{weakly preserve pullbacks}?
        This would be the classical definition.
\end{itemize}

\subsection{Using Coinductive Types?}

\begin{itemize}
    \item It is not clear that Agda's coinductive types
        interacts well with HITs.
    \item This might not work with the groupoid-definition:
        Either we use HITs (possibly inconsistent, for the small Bij),
        or the construction ends up being too large.
    \item
        Another approach: Quotient the (entire) final coalgebra of lists.
\end{itemize}

\section{Conclusions}

Connections with Piceghello \cite{Piceghello2021}.
He defines the free symmetric monoidal groupoid on a type
  as a HITs.


\subsubsection{Acknowledgements}
  This work was supported by the Estonian Research Council grant PSG749.

%\nocite{*}

\bibliographystyle{splncs04}
\bibliography{Multiset}
\end{document}
