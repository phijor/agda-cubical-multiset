\documentclass[runningheads]{llncs}

\usepackage[debug]{multiset}

\usepackage{bussproofs}

\usepackage{todonotes}

\begin{document}

\title{The Final Coalgebra of the Finite Bag Functor, Constructively}
\author{%
    Philipp Joram\orcidID{0000-0002-0448-7907} \and
    Niccolò Veltri\orcidID{0000-0002-7230-3436}%
}
%
\authorrunning{P. Joram and N. Veltri}
\institute{Department of Software Science, Tallinn University of Technology, Estonia}

\maketitle              % typeset the header of the contribution

\begin{abstract}

  Coalgebras for the finite bag functor are dynamical systems where the transition relation is resource-sensitive: the collection of reachable states records the number of ways in which each state can be reached. The final coalgebra of the finite bag functor is employed as a denotational domain for the evaluation of such dynamical systems. Its elements are non-wellfounded trees with finite unordered branching, depicting the evolution of systems starting from a given initial state.

  This paper is dedicated to the construction of the final coalgebra of the finite bag functor in homotopy type theory (HoTT). We first compare various equivalent definitions of finite bags employing higher inductive types, both as sets and as groupoids (in the sense of HoTT). We then analyze a few classical set-theoretic constructions of final coalgebras in our constructive setting. We show that, in the case of set-based definitions of finite bags, these constructions are either intrinsically classical, in the sense that they are equivalent to some weak form of excluded middle, or cannot be directly reproduced in HoTT without the assumption of classical principles. The final coalgebra can be safely constructed in HoTT only employing the groupoid-based definition of finite bags. We discuss generalizations of these constructions to more general analytic functors. We also show how Cubical Agda's coinductive types can be used to build the final coalgebra of the finite bag functor. 

\keywords{finite bags \and final coalgebra \and homotopy type theory.}
\end{abstract}

\setcounter{tocdepth}{1}
\tableofcontents

\section{Introduction}

\emph{Coalgebras} are functions of the form $c : S \to F S$, where $S$ is a set of states and $F$ is a functor specifying a certain class of collections of states \cite{Rutten2000,Jacobs2016}. For example, $F S$ could be lists over $S$, bags or subsets of $S$ (possibly with some cardinality restrictions), wellfounded trees with leaves or nodes in $S$, or probability distributions over $S$. The coalgebra $c$ describes the dynamics of a transition system or an automaton: to each state $s : S$, the function $c$ associates the collection of states $c \,s : F S$ that are reachable from $s$ in one step. The choice of collection functor $F$ is dictated by the specific flavour of non-determinism that is intrinsic in the transition relation. Does the order or multiplicity of reachable states matter? Is the choice of a new state probabilistic? Does the transition relation additionally depend on a set of labels, weights or actions?

The denotational semantics of a transition system $c : S \to F S$ is typically given in terms of the \emph{final coalgebra} $\nu F$ of the functor $F$, which  consists of non-wellfounded trees with branching specified by $F$. When $F$ is the list functor, each tree has a finite and ordered collection of subtrees. If $F$ is the finite bag functor, the order of subtrees does not matter, and if $F$ is the finite powerset functor, multiplicity of subtrees does not matter either. %Picking $F$ as the finite probability distribution functor, the trees correspond to
The interpretation of a state $s : S$ in $\nu F$ is the possibly-infinite tree obtained by ``running'' the coalgebra $c$ with $s$ as initial state. As such, it gives a complete description of the evolution of the system $c$ starting from state $s$.

The theory of dynamical systems as coalgebras \cite{Rutten2000,Jacobs2016}, and in particular the formal description of final coalgebras \cite{Barr1993,Adamek1995,Worrell2005} and the associated notion of bisimilarity and behavioural equivalence of states, is traditionally developed in a set-theoretic framework, with reasoning based on classical logic. In this work, we propose to study the theory of coalgebras in a framework based on constructive logic, more specifically in homotopy type theory (HoTT) \cite{HoTTBook}. The use of a constructive metatheory is beneficial for the development of \emph{formal denotational semantics} of dynamical systems and programming languages, often centered on the notions of final coalgebra and bisimilarity \cite{Turi1997}, in proof assistants based on variants of Martin-L{\"o}f type theory, such as Agda, Coq, Idris or Lean. The specific choice of HoTT is motivated by its expressivity and innovative features, higher inductive types (HITs) and the univalence principle, which are crucial ingredients for faithfully representing a variety of collection functors $F$ and reasoning up to equivalent presentations of $F$. 

Specific constructions of final coalgebras for a selection of functors, performed \emph{internally} in HoTT, already exist in the literature. Ahrens el al.~\cite{Ahrens2015} presented a construction of \emph{M-types}, i.e. final coalgebras of polynomial functors. They show that, for a polynomial functor $F$, the traditional set-theoretic construction of its M-type as the $\omega$-limit of the chain
\begin{equation}\label{eq:chain}
    1 \xleftarrow{!} {F 1}
      \xleftarrow{F !} {F^2 1}
      \xleftarrow{F^2 !} {F^3 1}
      \xleftarrow{F^3 !}
      \cdots
\end{equation}
(with $1$ being the unit type and $!$ the unique map into $1$) can be ported without major complications to the setting of HoTT. Veltri \cite{Veltri2021} exhamined various constructions of the final coalgebra of the finite powerset functor, which is known to not be definable as an $\omega$-limit \cite{Adamek1995}. Worrell proposed a set-theoretic construction as a $(\omega+\omega)$-limit \cite{Worrell2005}, but Veltri showed that this cannot be ported to the constructive setting of HoTT: Worrell's $(\omega+\omega)$-limit is the final coalgebra of the finite powerset functor if and only if the \emph{lesser limited principle of omniscience} ($\LLPO$) holds, which is a constructive taboo \cite{Bridges1987}.


We extend this line of work by studying the final coalgebra of the \emph{finite bag functor}. This is an intermediate situation between finitary polynomial functors, such as the one delivering lists, and general finitary functors, such as the one delivering finite subsets. It also serves as the starting point for a constructive analysis of (final) coalgebras for the \emph{analytic functors} of Joyal \cite{Joyal1986}, arising in type theory from \emph{quotient containers} \cite{Abbott2004}, and generally encompassing many datatypes with symmetries associated to generalized species, such as finite bags, unordered pairs and cyclic lists \cite{Yorgey2010,Yorgey2014}.

Following the recent work of Choudhury and Fiore \cite{Choudhury2021}, we define and compare various implementations of the type of finite bags in HoTT. Choudhury and Fiore give two equivalent presentations of finite bags as HITs: as free commutative monoids and as lists modulo swapping of adjacent entries. We add an equivalent presentation of finite bags as an analytic functor: a finite bag $\FMSet X$ over a type $X$ is a pair of a natural number $n$ (its size) and an equivalence class of functions typed $\Fin n \to X$ picking an element of $X$ for each $k < n$. Two functions $f ,g :\Fin n \to X$ belong to the same equivalence class if there merely exists an equivalence $\sigma : \Fin n \to \Fin n$ such that $f \circ \sigma = g$. The type $\FMSet X$ is always a set (in the sense of HoTT, i.e. a type with at most one identification between any two terms), since it employs set-quotienting. Similarly, the HITs of Choudhury and Fiore are sets. Following \cite{Kock2012}, finite bags can alternatively be defined as a polynomial functor returning a groupoid (in the sense of HoTT, i.e. a type whose equality types are sets) instead of a set. In this case, a finite bag $\Bag X$ over $X$ is a pair consisting of a finite type $Y$ and a function from $Y$ to $X$. The set-based and the groupoid-based definitions of bags can be appropriately related via the set-truncation construction: $\SetTrunc{\Bag X} \simeq \FMSet X$.

We present 3 constructions of the final coalgebra of the finite bag functor:
\begin{enumerate}
\item Working with the set-based functor $\FMSet$, we try to replicate the classical set-theoretic construction as an $\omega$-limit of (\ref{eq:chain}) in our constructive setting. We show that this cannot be directly performed in HoTT without introducing some form of classical logic, an issue already spotted in the case of the finite powerset functor \cite{Veltri2021}. Formally, we show that $\FMSet$ weakly preserves the $\omega$-limit of (\ref{eq:chain}) (actually all $\omega$-limits if one assumes the axiom of countable choice), but strong preservation of this limit implies $\LLPO$.
\item The list functor admits a final coalgebra $\nu\List$ in HoTT \cite{Ahrens2015} and classically an appropriate quotient of the latter, by a relation $R$ identifying non-wellfounded trees which differ in the order of their subtrees, delivers the final coalgebra of the bag functor. This construction can be smoothly replicated as a \emph{strict} $\omega$-limit in the category of \emph{setoids} \cite{Barthe2003}. Problems arise when trying to port the latter from setoids to sets, effectively forming the set-quotient $\nu\List \mathbin{/_{\!2}} R$: we prove that the resulting type is a fixpoint for $\FMSet$, in the sense that $\FMSet (\nu\List \mathbin{/_{\!2}} R) \simeq \nu\List \mathbin{/_{\!2}} R$, but showing that this is the final coalgebra requires the assumption of the full axiom of choice. 
\item The groupoid-based polynomial functor $\Bag$ admits a final coalgebra $\nu\Bag$ as the $\omega$-limit of (\ref{eq:chain}), a result arising directly from the work of Ahrens et al.~\cite{Ahrens2015}. $\nu\Bag$ is a groupoid, not a set. One might wonder if the set-truncation $\SetTrunc{\nu\Bag}$ is a good candidate for the final $\FMSet$-coalgebra. We  show that it is a fixpoint of $\FMSet$, but showing that it is the final coalgebra seems to again require the axiom of choice. 
\end{enumerate}
Practically, the last two constructions, while not generally delivering the final coalgebra of the set-based bag functor, can still be used as denotational domains for resource-sensitive transition systems with a \emph{finite} set of states \cite{Frumin2018}: given a coalgebra $c : S \to \FMSet S$ where $S$ is (Bishop) finite, there exists a unique coalgebra morphism from $S$ to $\nu\List \mathbin{/_{\!2}} R$, and also from $S$ to $\SetTrunc{\nu\Bag}$.

We finally discuss generalizations of our constructions to other analytic functors. We also look at an alternative construction of the final $\FMSet$-coalgebra using Cubical Agda's primitive \emph{coinductive types} \cite{Vezzosi2019}. In Cubical Agda, HITs such as $\FMSet X$ can appear in the codomain of coinductive type destructors, which is intuitively justified by the treatment of HITs in Cubical Agda as inductive types with constructors possibly depending on interval variables \cite{Coquand2018,Cavallo2019}.

The material presented in the paper have been formalized in the Cubical Agda proof
assistant. The code is freely available at \url{https://github.com/phijor/agda-cubical-multiset}.

\section{Type Theory and Cubical Agda}

We work in homotopy type theory \cite{HoTTBook} and practically our formalization takes place in Cubical Agda \cite{Vezzosi2019}. In this section we recall some basic notions that are employed in our development.

Given a type $A$ and a type family $B$ on $A$, the associated dependent function type is $(x : A) \to B \, x$. Implicit arguments of dependent functions are enclosed in curly brackets. Basics inductive types include: unit type $1$, empty type $\bot$, Booleans values $\Bool$, natural numbers $ℕ$, finite prefixes of the naturals $\Fin n$, lists $\List A$, dependent pairs $\sum (x : A) \Where B \, x$, binary sum $A + B$ and products $A \times B$. We use standard names for their constructors. The unique function from a type $A$ into the unit type is called $! : A \to 1$. Membership in a list is $x \in xs$ and removal of an occurrence $m : x \in xs$ is $xs \setminus m$. Given an inductive type $T$, we write $\Elim{T}$ and $\Rec{T}$ for its dependent and non-dependent elimination  principles, respectively (we employ the same notation also for higher inductive types, introduced in the end of this section). The action on maps of a functor $F : \Type \to \Type$ is $\Map{F}$. Most of our constructions are universe-polymorphic, but for the sake of readibility in the paper we use only the two lowest universe of types, $\Type$ and $\Type_1$.

Given $x, y : A$, their definitional equality is denoted $x \DefEq y$ while propositional equality is $x = y$.
Following ``cubical terminology'', the latter is called the \emph{path type} between $x$ and $y$.
In Cubical Agda, the path type $x = y$ behaves similarly to a function type $\Interval \to A$, where $\Interval$ is a primitive interval type with endpoints $i_0$ and $i_1$.
An element $p : x = y$ is eliminated by application to an interval name $r : \Interval$, returning $p \, r : A$.
But unlike function types, this application can compute even when $p$ is unknown by using the endpoints $x$ and $y$: $p \,i_0$ reduces to $x$ and $p \,i_1$ reduces to $y$.
Path introduction is lambda abstraction $(\lambda i : \Interval.\,t) : x = y$, but it causes the extra requirement to match the endpoints: $t[i_0 / i]$ is judgementally equal to $x$ and $t[i_1 / i]$ is judgementally equal to  $y$. 

A function $f : A \to B$ is an \emph{equivalence} if it has contractible fibers, i.e. if the preimage of any element in $B$ under $f$ is a singleton type. Any function underlying a type isomorphism defines an equivalence. Writing $A \simeq B$ for the type of equivalences between $A$ and $B$, Voevodsky's \emph{univalence principle} states that the canonical function of type $A = B \to A \simeq B$ is an equivalence. This is a theorem in Cubical Agda. In particular, there is a function $\operatorname{ua} : A \simeq B \to A = B$ turning equivalences into path equalities. Univalence implies \emph{function extensionality}: pointwise equal functions are equal.

We recall the first instances of the hierarchy of \emph{homotopy levels}, and say that a type $A$ is:
\begin{itemize}
  \item ($n = 1$) a \emph{proposition}, if
    $\IsProp A \DefEq (a , b : A)\Where a = b$ is inhabited,
  \item ($n = 2$) a \emph{set}, if
    $\IsSet A \DefEq (a, b : A)\Where \IsProp \ (a = b)$ is inhabited,
  \item ($n = 3$) a \emph{groupoid}, if
    $\IsGpd A \DefEq (a, b : A)\Where \IsSet \ (a = b)$ is inhabited.
\end{itemize}
When mentioning \enquote{sets} or \enquote{groupoids}, we always refer to the definition above.

A \emph{higher inductive type} (HIT) is like an inductive type, but its constructors can build both its elements and its (higher) paths. HITs are primitively supported in Cubical Agda. We recall the definition of three basic HITs: propositional truncation, set truncation and the set quotient. 

The \emph{propositional truncation} $\PropTrunc{A}$ is the proposition associated to the type $A$, i.e. it unifies all the elements and (higher) paths of $A$. It is the HIT with constructors
\begin{center}
  \hspace*{\fill}
    \AxiomC{$a : A$}
    \UnaryInfC{
      $\PropTruncCon[a] : \PropTrunc{A}$
    }
    \DisplayProof
  \hfill
    \AxiomC{$x, y : \PropTrunc{A}$}
    \UnaryInfC{$\PropTruncSquash\,x\,y : x = y$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
We define the \emph{existential quantifier} $\exists (x : A) \Where B\, x \DefEq \PropTrunc{\sum (x : A) \Where B\,x}$, which records the mere existence of an element $x$ satisfying $B$.    

The \emph{set truncation} $\SetTrunc{A}$ is the set associated to the type $A$, i.e. it unifies all (higher) paths of $A$. It is the HIT with constructors
\begin{center}
  \hspace*{\fill}
    \AxiomC{$a : A$}
    \UnaryInfC{
      $\SetTruncCon[a] : \SetTrunc{A}$
    }
    \DisplayProof
  \hfill
    \AxiomC{$x, y : \SetTrunc{A}$}
    \AxiomC{$p, q : x = y$}
    \BinaryInfC{$\SetTruncSquash\,p\,q : p = q$}
    \DisplayProof
  \hspace*{\fill}
\end{center}

The \emph{set quotient} $\SetQuot[A][R]$ of a type $A$ by a (possibly proof-relevant) relation
$R : A \to A \to \Type$ is the HIT with constructors
\begin{center}
  \hspace*{\fill}
    \AxiomC{$a : A$}
    \UnaryInfC{
      $\SetQuotCon[a] : \SetQuot[A][R]$
    }
    \DisplayProof
  \hfill
    \AxiomC{$a, b : A$}
    \AxiomC{$r : R \,a\, b$}
    \BinaryInfC{$\operatorname{\mathsf{eq/}}_{\!\mathsf{2}}\,r : \SetQuotCon[a] = \SetQuotCon[b]$}
    \DisplayProof
  \hfill
    \AxiomC{$x, y : \SetQuot[A][R]$}
    \AxiomC{$p, q : x = y$}
    \BinaryInfC{$\SetQuotSquash\,p\,q : p = q$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
The term $\SetQuotCon[a]$ is the $R$-equivalence class of $a$, while the path constructor $\operatorname{\mathsf{eq/}}_{\!\mathsf{2}}$ states that $R$-related elements have path equal equivalence classes. The higher path constructor $\SetQuotSquash$ forces $\SetQuot[A][R]$ to be a set. A set-quotient $\SetQuot[A][R]$ is called \emph{definable} if the equivalence class constructor has a section, i.e. there is a representative-picking function $\rep: \SetQuot[A][R] \, \to A$ such that $\SetQuotCon[\rep\,x] = x$ for all $x : \SetQuot[A][R]$ \cite{Li2015}.

Other HITs are presented in the next section, where we also take a closer look at their elimination principles.



\section{The Finite Bag Functor in Sets}\label{sec:finite-bags-sets}

The action of the finite bag functor on a type $X$ can be encoded as higher inductive
types in various ways, three of which are presented here. 
The first is as the free commutative monoid, the second as lists modulo permutations,
%set-quotiented by an \emph{up to permutation}-relation,
the third as an analytic functor. These are all set-based definitions, in the sense that the type of finite bags is a set. Groupoid-based definitions are discussed in Section~\ref{sec:finite-bags-groupoids}.

\subsection{As the Free Commutative Monoid}

Given a type $X$, the \emph{free commutative monoid} on $X$
\cite{Choudhury2021} is the HIT $\M X$ induced by the following rules:
%\begin{itemize}
%  \item Point constructors:
    \begin{center}
      \hspace*{\fill}
        \AxiomC{$\vphantom{X}$}
        \UnaryInfC{$\Empty : \M{X}$}
        \DisplayProof
      \hfill
        \AxiomC{$x : X$}
        \UnaryInfC{$\Singl x : \M X$}
        \DisplayProof
      \hfill
        \hspace{10pt}
        \AxiomC{$xs, ys : \M X$}
        \UnaryInfC{$\Var{xs} \Union \Var{ys} : \M X$}
        \DisplayProof
      \hspace*{\fill}
%    \end{center}
 % \item Monoid axioms and commutativity:
      \\[6pt]
%    \begin{center}
      \hspace*{\fill}
        \AxiomC{$\Var{xs} : \M X$}
        \UnaryInfC{$\mathsf{unit} : \Empty \Union \Var{xs} = \Var{xs}$}
        \DisplayProof
      \hfill
        \AxiomC{$\Var{xs}, \Var{ys}, \Var{xs} : \M X$}
        \UnaryInfC{
          $\mathsf{assoc} : \Var{xs}\Union(\Var{ys}\Union\Var{zs}) = (\Var{xs}\Union\Var{ys})\Union\Var{zs}$
        }
        \DisplayProof
      \hspace*{\fill}
      \\[6pt]
      \hspace*{\fill}
        \AxiomC{$\Var{xs}, \Var{ys} : \M X$}
        \UnaryInfC{
          $\mathsf{comm} : \Var{xs}\Union\Var{ys} = \Var{ys}\Union\Var{xs}$
        }
        \DisplayProof
      \hspace*{\fill}
%    \end{center}
%  \item set truncation:
%    \begin{center}
%      \hspace*{\fill}
        \AxiomC{$\Var{xs}, \Var{ys} : \M X$}
        \AxiomC{$p, q : \Var{xs} = \Var{ys}$}
        \BinaryInfC{
          $\mathsf{trunc} : p = q$
        }
        \DisplayProof
      \hspace*{\fill}
    \end{center}
%\end{itemize}

The costructor $\Singl$ embeds $X$ into $\M X$, while $\Empty$ and $\Union$ are the unit and multiplication of the monoid. The path constructors express unitality of $\Empty$ wrt. $\Union$, associativity and commutativity of $\Union$, and the final higher path constructor forces $\M X$ to be a set.

In Cubical Agda, functions out of HITs like $\M X$ can be defined directly by pattern matching. But it is often useful to have elimination principles at hand that give more control on the shape of the proof obligations. For example, the non-dependent elimination principle of $\M X$ states that a function of type $\M X \to A$ is definable, provided that $A$ is a commutative monoid and there exists a function $\eta^* : X \to A$.
\begin{align*}
  \Rec{\M X} &: \{A : \Type\} → \IsSet A \\
    &→ (\varepsilon^* : A) \,(\eta^* : X → A) \, (({+}) : A → A → A) \\
    &→ (∀ a\Where \varepsilon^* + a = a) \\
    &→ (∀ a\, b\, c\Where a + (b + c) = (a + b) + c) \\
    &→ (∀ a\, b\Where a + b = b + a) \\
    &→ \M X → A
\end{align*}
$\M$ is a functor, with action on maps given by
\begin{align*}
  &\Map{M} : (f : X \to Y) \to \M X \to \M Y \\
  &\Map{M}\,f \DefEq \Rec{\M X}\;\mathsf{trunc}\;\Empty\;(\eta \circ f)\;(\Union)\;\mathsf{unit}\;\mathsf{assoc}\;\mathsf{comm}
\end{align*}

\subsection{As a Quotient of Lists}

Another standard definition of the type of finite multisets is as lists modulo permutations. The relation specifying the existence of a permutation between two lists can be given in multiple ways, here we mention two possibilities.

Given $xs, ys : \List X$, the relation $\Perm \,xs \,ys$ is generated by the rules:
\begin{center}
  \hspace*{\fill}
    \AxiomC{$\vphantom{X}$}
    \UnaryInfC{$\Perm \, xs\, xs$}
    \DisplayProof
  \hfill
    \AxiomC{$\Perm\, (xs \Append x \Cons y \Cons ys)\,zs$}
    \UnaryInfC{$\Perm\, (xs \Append y \Cons x \Cons ys)\,zs$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
In other words, $\Perm$ is the reflexive-transitive closure of the relation generated by pairs of lists of the form $xs \Append x \Cons y \Cons ys$ and $xs \Append x \Cons y \Cons ys$. This is a very intensional way of representing permutations of lists: a proof of $\Perm\, xs\, ys$ not only records where each entry in $xs$ is moved to in $ys$, but also how it is moved there. As such, $\Perm \, xs\,ys$ is not a proposition. 

Another way of specifying permutations is via a \emph{relation lifting}, often called a \emph{relator} \cite{Levy2011}. Given a relation $R$ on a type $X$, we inductively define a relation $\DRelator \, R$ on $\List X$, which intuitively states that each occurrence of an element $x$ in the first list is $R$-related to the occurrence of an element $y$ in the second list.
\begin{center}
  \hspace*{\fill}
    \AxiomC{$\vphantom{X}$}
    \UnaryInfC{$\DRelator\, R\; [\ ]\; ys$}
    \DisplayProof
  \hfill
    \AxiomC{$\exists (y : Y) \Where \sum (m : y \in ys) \Where R\;x\;y \times \DRelator\,R\;xs\;(ys \setminus m)$}
    \UnaryInfC{$\DRelator\, R\; (x \Cons xs)\;ys$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
The relation lifting of $R$ is the symmetric closure of $\DRelator\,R$, i.e. $\Relator\,R\;xs\;ys \DefEq \DRelator\,R\;xs\;ys \times \DRelator\,R\;ys\;xs$.
Because of the presence of a propositional trunctation in the premise of the 2nd rule, both $\DRelator\,R$ and $\Relator\,R$ are propositionally-valued. If $R$ is reflexive and transitive, than $\Relator\,R$ is an equivalence relation.

When $R$ is path equality on $X$, the type $\Relator\,(=)\;xs\;ys$ expresses the existence of a permutation connecting $xs$ and $ys$. In fact, there is a bi-implication between $\Perm\;xs\;ys$ and $\Relator\,(=)\;xs\;ys$. Therefore, we have two equivalent presentations of lists modulo permutations: $\SetQuot[\List X][\Perm]$ and $\SetQuot[\List X][\Relator\,(=)]$. They are also both equivalent to $\M X$.

\subsection{As an Analytic Functor}

Finally, we define the type of finite multisets over $X$ as an \emph{analytic functor}~\cite{Joyal1986}, which is provably equivalent to $\M X$, $\SetQuot[\List X][\Perm]$ and $\SetQuot[\List X][\DRelator\,(=)]$.
\begin{align*}
  \FMSet X
    \DefEq
    \sum (\Var{n} : ℕ) \Where
      \SetQuot[(\Fin \Var{n} \to X)][\SymAct \Var{n}]
\end{align*}
where $\sim$ is the propositionally-valued relation 
\begin{align*}
  \SymAct n \;v \;w &\mathrel{=_{\mathsf{df}}}
    ∃ (\sigma : \Fin n ≃ \Fin n) \Where
      v = w \circ \sigma
\end{align*}
In other words, an element of $\FMSet X$ is a pair of a natural numbers $n$ (the size of the multiset) and an equivalence class of functions $v : \Fin n \to X$ picking an element in $X$ for each index $k < n$. The relation $\SymAct n$ is the action of the symmetric group $\Fin n \simeq \Fin n$ on $n$-tuples of elements of $X$. By taking a different subgroup of the symmetric group one obtains different analytic functors, e.g. by restricting to cyclic permutations one gets cyclic lists. We write $\SymActSigma n$ for the non-propositionally truncated variant of $\SymAct n$. We write $v \sim w$ instead of $\SymAct n \;v \;w$ when $n$ is clear from context, and analogously $\SetQuot[(\Fin n \to X)][\sim]$ in place of $\SetQuot[(\Fin \Var{n} \to X)][\SymAct \Var{n}]$.





%% \begin{definition}
%%   The recursion principle for $\FMSet X$ is the function
%%   \begin{align*}
%%     \Rec{\FMSet}
%%       &: \{A : \Type\} → \IsSet{A} \\
%%       &→ (\Op{as} : \{n : ℕ\} → (v : \Fin n → X) → A) \\
%%       &→ (∀ n\Where (v, w : \Fin n → X) → v \sim_n w → \Op{as} v = \Op{as} w) \\
%%       &→ \FMSet X → A
%%   \end{align*}
%%   defined from the recursion principle of set-quotients.
%%   Similarly, we define the induction principle $\Op{elim}_{\FMSet}$ for
%%   a dependent type family $B : \FMSet X → \Type$ of sets.
%% \end{definition}

%\subsubsection{Finite Choice for Sets}

The proof of Theorem~\ref{thm:FMSetFixpointOfTrunc} employs the fact that $\FMSet$ is closed under set truncation.  The proof factors through the following lemma, stating that set truncation distributes over finite families of types.
\begin{lemma}\label{lem:FiniteChoice}
  For any $n : ℕ$ and type family $Y : \Fin n \to \Type$,
  there is an equivalence
  $
    \Op{box} :
    ((k : \Fin n) → \SetTrunc{\mathop{Y\/} k})
    ≃
    {\SetTrunc{(k : \Fin n) → \mathop{Y\/} k}}.
  $
\end{lemma}
\begin{proof}
  We sketch a proof for a constant type family $Y = (\lambda \Blank \Where X)$.
  The dependent case is analogous.
  The function underlying the equivalence is defined by induction on $n$.
  For $n = 0$ we have $\Fin 0 ≃ \bot$,
  so $\Op{box} \DefEq (\lambda \Blank\Where \SetTruncCon[\Elim{\bot}])$.
  In the inductive step, we lift the \enquote{cons} operation
  $
    (\Cons) : X → (\Fin n → X) → (\Fin{} (1 + n) → X)
  $
  on vectors to the set-truncation.
  A two-sided inverse $\Op{unbox} : \SetTrunc{\Fin n → X} → \Fin n → \SetTrunc{X}$ of $\Op{box}$ is given by $\Op{unbox} \bar{v}\, k \DefEq \Map{\SetTrunc{\Blank}} (\lambda v\Where v\, k)\, \bar{v}$.
  %By induction on $n$, we see that
  %\begin{align*}
  %  & \Op{unbox} : \SetTrunc{\Fin n → X} → \Fin n → \SetTrunc{X}\\
  %  &\Op{unbox} \bar{v}\, k \DefEq \Map{\SetTrunc{\Blank}} (\lambda v\Where v\, k)\, \bar{v}
  %\end{align*}
  %The proof uses the fact that $\Map{\SetTrunc{\Blank}}$ is functorial.
\end{proof}
%\begin{definition}
The equivalence of Lemma \ref{lem:FiniteChoice} allows to define a variant of the elimination principle $\Elim{\SetTrunc{\Blank}}$ which takes $\Fin n \to \SetTrunc{X}$ as input (a sort of ``finite choice'' principle for set truncation)
%taking The principle of finite choice can be defined in terms of $\Op{box}$:
  \begin{align*}
    \FinElim &: \{n : ℕ\}\, \{B : (\Fin n \to \SetTrunc{X}) \to \Type\} \to (\forall v\Where \IsSet (B\, v)) \\
      &\to ((w : \Fin n \to X) \to B\, (\SetTruncCon{} \circ w)) \\
      &\to (v : \Fin n \to \SetTrunc{X}) \to B\, v)
  \end{align*}
 % It is defined by applying $\mathsf{choice}$ to the term obtained from
 % set-truncation elimination on $\operatorname{box} v$.
  which furthermore comes with a (propositional) computational rule
  %\begin{align*}
    $\FinElimComp : (v : \Fin n → X)
      → \FinElim (\SetTruncCon{} \circ v) = \operatorname{\mathsf{choice}} v$.
  %\end{align*}
%\end{definition}

\begin{theorem}\label{thm:FMSetSetTruncInvariant}
  $\FMSet$ is invariant under set-truncation: $\FMSet \SetTrunc{X} ≃ \FMSet X$.
\end{theorem}
\begin{proof}
  The equivalence is obtained from an isomorphism.
  The right-to-left map is $\Map{\FMSet}\,\SetTruncCon{}$.
  For the left-to-right map, we use $\FinElim$ to define a function typed
$  %\[
    %\Op{requot} : ∀ \{n\}\Where
    (\Fin n → \SetTrunc{X})
    → \SetQuot[(\Fin n → X)][\sim]
  %\]
  $
  that turns set truncation into a set quotient, %and to prove that the latter preserves $(\sim)$.
  %By recursion on $\FMSet \SetTrunc{X}$,
  which is enough to obtain a function typed $\FMSet \SetTrunc{X} → \FMSet X$.
  That these maps are mutual inverses follows from $\FinElimComp$.
\end{proof}

\subsection{Definable Quotients and Sorting}\label{sec:Sorting}

The proof of Theorem~\ref{thm:InjPresSurjective} relies on the validity of two specific instances of the axiom of countable choice. We show here that these instances hold and therefore Theorem~\ref{thm:InjPresSurjective} is true without the need of postulating countable choice. This is achieved by showing that, whenever a type $X$ is endowed with a linear order $(<)$, then $\SetQuot[\List X][\Perm]$ is a definable set-quotient.

Remember that a relation $(<)$ is a \emph{linear order} when it is asymmetric, transitive, propositinally-valued and total, in the sense that the trichotomy $(x < y) + (x = y) + (y < x)$ holds for all $x,y:X$.
If $X$ has a linear order $(<)$, then lists over $X$ can be sorted wrt. $(<)$ via function $\sort : \List X \to \List X$ intuitively implementing the insertion-sort algorithm. We can show $\Perm \,xs\,(\sort\,xs)$. Sorting is independent of the positions of each entry in the input list, therefore via the recursion principle of set-quotients we obtain a function $\sortPerm : \SetQuot[\List X][\Perm] \to \List X$. It is not hard to show that $\sortPerm$ is a section of the equivalence class constructor, so $\SetQuot[\List X][\Perm]$ is a definable quotient.
The latter is equivalent to $\FMSet X$, which implies the following result.
\begin{proposition}\label{prop:ListPermDefQuot}
If $X$ is linearly-ordered, then $\SetQuot[(\Fin n \to X)][\sim]$ is a definable quotient for all $n : ℕ$.
\end{proposition}

Sorting also allows us to explicitly find a canonical permutation between any two related lists. Given $p : \Perm \,xs\,ys$, we can find another proof $\canonicalPerm \;p : \Perm\,xs\,ys$: there are permutations $\Perm\,xs\,(\sort\,xs)$ and $\Perm\,(\sort\,ys)\,ys$, and moreover the existence of the given permutation $p$ implies $\sort\,xs = \sort\,ys$. The function $\canonicalPerm$ is constant, since its definition never inspect the input permutation $p$. 
\begin{proposition}\label{prop:ListPermDefQuot}
If $X$ is linearly-ordered, then for all $n : ℕ$ and $v,w : \Fin n \to X$ there exists a function typed $\SymAct n\; v\; w \to \SymActSigma n \;v \; w$ , i.e. the propositional truncation in $\SymAct n\; v\; w$ can be removed.
\end{proposition}

A linear order $(<)$ on $X$ can be extended to a linear order on $\List X$ via the \emph{lexicographic order}:
\begin{center}
  \hspace*{\fill}
    \AxiomC{$\vphantom{X}$}
    \UnaryInfC{$\Lex\, (<)\; [\ ]\; ys$}
    \DisplayProof
  \hfill
    \AxiomC{$x < y$}
    \UnaryInfC{$\Lex\,(<)\;(x \Cons xs) \;(y \Cons ys)$}
    \DisplayProof
  \hfill
    \AxiomC{$x = y$}
    \AxiomC{$\Lex\,(<)\;xs\;ys$}
    \BinaryInfC{$\Lex\,(<)\;(x \Cons xs) \;(y \Cons ys)$}
    \DisplayProof
  \hspace*{\fill}
\end{center}
This can further be extended to a linear order on $\SetQuot[\List X][\Perm]$ as follows: $\LexPerm\,(<)\;x\;y \DefEq \Lex\,(<)\;(\sortPerm \,x)\;(\sortPerm \,y)$.
\begin{proposition}
If $X$ is linearly-ordered, then $\SetQuot[(\Fin n \to X)][\sim]$ is linearly-ordered for all $n : ℕ$.
  
\end{proposition}

\section{The Final Coalgebra in Sets}\label{sec:final-coalgebra-sets}

\section{The Finite Bag Functor in Groupoids}\label{sec:finite-bags-groupoids}

The results of Section~\ref{sec:final-coalgebra-sets} are evidence that the set-based definitions of finite bags from Section~\ref{sec:finite-bags-sets} are not fit for a fully constructive construction of the final coalgebra. In this section we start looking at groupoid-based definition and, following the ideas of \cite{Kock2012} and \cite{Finster2021},  argue that the correct perspective on finite bags in HoTT is to define them as groupoids instead of sets, particularly for the goal of final semantics.
The rationale is that identifications of bags are permutations, and these should inherently be treated as \emph{data}.
Instead of viewing bags as quotients of lists, thereby \enquote{forgetting} about the permutations,
we define a type of lists with \enquote{more identifications}.
Since all constructions based on this type have to be homotopy coherent,
they will automatically respect the extra data,
making them invariant under permutation for free.
We define a type family $\Bag : \Type → \Type$ of finite bags in groupoids,
and substantiate the previous claims by first showing that its set-truncation is equivalent to $\FMSet$ (\cref{thm:FMSetOfFMGpdTrunc}),
and later by constructing its final coalgebra in a straighforward way %(\cref{ssec:FMGpdLim},
(\cref{thm:FMGpdLim}).

\todo[inline]{%
  We should cite \cite{Piceghello2021} here.
  He defines the free symmetric monoidal groupoid on a type
  as a HITs (\enquote{s-lists}).
}

First, recall one way of defining finite sets in HoTT \cite{Frumin2018}.
%\begin{definition}
  A type $Y$ is called \emph{(Bishop-) finite} if
  $
    \Op{isFinSet} Y \DefEq
      \sum (n : ℕ)\Where \PropTrunc{Y ≃ \Fin n}
  $
  holds,
  and we denote the collection of such types by
  $
    \Op{FinSet} \DefEq
      \sum (Y : \Type)\Where \Op{isFinSet} Y.
  $
  The underlying type of a $\FinSet$ is accessed via the first projection $\langle\Blank\rangle : \FinSet → \Type$.
%\end{definition}

It is easy to show that $\Op{isFinSet}$ is a proposition and that any type satisfying the predicate is a set.
It follows that $\Op{FinSet}$ forms a groupoid.
Note that $\Op{FinSet}$ is a \emph{large} type, i.e. $\Op{FinSet} : \Type_1$.
%it lives in the successor universe of the types that it ranges over.
From this, we can define a \enquote{tote} $\Tote : \Type → \Type1$ (``tote'' in the sense of a ``large bag'') as
%, which we think of as a finite collection of elememts in $X$:
%\begin{definition}
%  A large type, $\Tote : \Type_\ell → \Type_{\ell + 1}$:
  \begin{align*}
    \Tote X
      \mathbin{=_{\mathrm{df}}}
      \sum\,(\Var{B} : \Op{FinSet})\Where \langle B \rangle \to X,
  \end{align*}
%\end{definition}
Elements of ...
In general, $\Tote X$ is at least a groupoid.

\begin{proposition}
  If $X$ is a groupoid, then $\Tote X$ is a groupoid.
\end{proposition}
\begin{proof}
  By assumption $X$ is a groupoid,
  so the function type $\langle Y \rangle → X$ is a groupoid
  for any $Y : \FinSet$.
  But $\FinSet$ is also a groupoid, therefore the entire $\Sigma$-type is a groupoid.
\end{proof}

As $\Tote X$ is a large type, it is unsuitable for iteration, as the assignment $(\lambda n\Where \Tote^n \mathsf{1})$
of $n$-fold applications of the family is not typeable in a universe of bounded size.
We will later\todo{\cref{def:Bag}} introduce an equivalent, small family $\Bag$ that avoids this issue, following \cite{Finster2021}.

\todo[inline]{%
  Relating $\Tote$ back to finite multisets:
}

\begin{theorem}\label{thm:FMSetOfFMGpdTrunc}
  Set-truncating a tote yields a finite multiset.
  For any type $X$,
  \[
    \SetTrunc{\Tote X} ≃ \FMSet X
  \]
\end{theorem}
\begin{proof}
  The proof proceeds by constructing an explicit isomorphism $\FMSet X \cong \SetTrunc{\Tote X}$.
  The forward direction is unproblematic, while the inverse function has to be carefully defined with the
  homotopy levels of the involved types in mind.

  \newcommand*{\ToTote}{\Op{toTote}}
  \newcommand*{\ToFMSet}{\Op{toFMSet}}

  To construct $\ToTote : \FMSet X → \SetTrunc{\Tote X}$, by the induction principle
  $\Elim{\FMSet}$, it is enough to give a function
  $f : \forall \{\Var{sz}\}\Where (\Fin \Var{sz} → X) → \SetTrunc{\Tote X}$
  and to show that it respects $(\sim)$.
  Let $f(v) \DefEq \SetTruncCon[(\Fin \Var{sz} , v)]$, since $\Fin \Var{sz}$ is obviously a finite set.
  To prove that $v \sim w$ implies $f(v) = f(w)$, we note that the conclusion is a proposition,
  thus by induction on $v \sim w$ obtain a permutation $\sigma$ such that $r : v = w \circ \sigma$.
  By univalence, $\Op{ua} \sigma : \Fin \Var{sz} = \Fin \Var{sz}$,
  and transporting $r$ along this path yields
  $
    p : (\Fin\Var{sz} , v) = (\Fin\Var{sz}, w)
  $.
  Then $\Op{cong} \SetTruncCon\, p : f(v) = f(w)$ as desired.

  In the other direction $\ToFMSet : \SetTrunc{\Tote X} → \FMSet X$
  is define by set-truncation elimination, and it is enough to provide
  \begin{align*}
    &g : \Tote{X} → \FMSet X \\
    &g\, (Y, \Var{sz}, e, v) \DefEq (\Var{sz} , g')
  \end{align*}
  where $Y$ is a finite set of size $\Var{sz}$ with $e : \PropTrunc{Y ≃ \Fin\Var{sz}}$ and $v : Y → X$.
  We would like to use a composition $\Fin\Var{sz} → Y → X$ to find
  $g' : \SetQuot[(\Fin\Var{sz} → X)][\mathord{\sim}]$,
  but one cannot do so because $e$ is propositionally truncated.
  Using induction directly on $e$ cannot work, since $g'$ lives in a set.
  We can however show that
  \begin{align*}
    &\operatorname{\mathsf{from-equiv}} : (Y ≃ \Fin\Var{sz}) → \SetQuot[(\Fin\Var{sz} → X)][\mathord{\sim}] \\
    &\operatorname{\mathsf{from-equiv}} \alpha \DefEq \SetQuotCon[v \circ \alpha]
  \end{align*}
  is \emph{weakly-constant} in the sense of \cite{Kraus2017} to obtain $g'$ from $e$ using the elimination
  principle of \cite[{Corollary~2}]{Capriotti2015}.
  Proving $\ToFMSet \circ \ToTote = \Op{id}$ is straightforward.
  Proving $\ToTote \circ \ToFMSet = \Op{id}$ reduces to showing that $v \circ \alpha \sim v$ for any $v : Y → X$ and $\alpha : \Fin n ≃ Y$.
\end{proof}

\begin{definition}\label{def:Bag}
  A small type:
  \begin{align*}
    \Bag X
      \mathbin{=_{\mathrm{df}}}
      \sum\,\Var{x} : \operatorname{\mathsf{Bij}}\Where
        \langle x \rangle \to X,
  \end{align*}
  We abbreviate $\BagCon{v} \DefEq (x, v) : \Bag X$ if $x$ can be inferred from context.
\end{definition}

\paragraph{Comparing $\Op{List}$ and $\Bag$}\todo{Fit this comparison in somewhere}
Note that $\Bag$ is somewhat analogous to $\Op{List}$:
Given a type $A$ and a family $B$ over it, they both match ${\sum (a : A)\Where B(a) → X}$:
we have $A = ℕ$ and $B = \Fin$ for $\Op{List}$,
and $A = \Bij$ and $B = \BagCon{\Blank}$ for $\Bag$.
In particular, $\SetTrunc{\Bij} ≃ ℕ$.

\section{The Final Coalgebra}

Describe limits in general.
Maybe compare final coalgebras and corecursive algebras which are fixpoints.
\todo[inline]{%
  Mention what the type of final coalgebras is.
  Use contractibility for UP.
}

\subsection{$\omega$-Chains and Limits}

\begin{itemize}
  \item definition of chains (in type theory)
  \item define type of limits, mention universal property
  \item shifted limit
  \item mention that $\Op{pres}$ is given by the UP
\end{itemize}

\subsection{Final Coalgebras as an \ensuremath{\omega}-Limit in Set}

\todo[inline]{%
    Surjectivity works (under the assumption of countable(?) choice).
}

\begin{theorem}\label{thm:InjPresImpliesLLPO}
  The injectivity of the function
  $\Op{pres}\colon
      \FMSet (\lim_{n < \omega} \FMSet^n 1)
      \to
      \lim_{n < \omega} (\FMSet^{n+1} 1)$
  is equivalent to the \emph{lesser limited principle of omniscience}, \LLPO.
\end{theorem}
\LLPO{} \cite[{Ch.\@ 1}]{Bridges1987} is a weak version of the law
of the excluded middle, and it is not provable from intuitionistic
axioms alone.  It states that, given an infinite stream of boolean
values that yields $\True$ in at most one position, one can decide
whether all even or all odd positions are $\False$.

\begin{proof}[\cref{thm:InjPresImpliesLLPO}]
  Both injectivity and \LLPO{} are propositions, so we show equivalence from bi-implication.
  \Cref{lem:InjPresImpliesComplete} shows that injectivity implies completeness of $L_{\FMSet}$,
  which implies injectivity (\cite[{Theorem~7}]{Veltri2021}).
  The other direction is done in \cref{lem:LLPOImpliesPresInj}.
\end{proof}

\begin{theorem}\label{thm:InjPresSurjective}
  $\Op{pres}$ is surjective.
\end{theorem}

\begin{lemma}\label{lem:DiagLimCaseAnalysis}
  For any $x, a, b : L_{\FMSet}$ and $\Var{ys} : ℕ → L_{\FMSet}$,
  if $\Op{diag} : ∀ n\Where x_n = \Var{ys}(n)_n$,
  then
  \[
    ∀ n\Where (\Var{ys}(n) = a) → (\Var{ys}(1+n) = b) → (!^n (a_{1+n}) = b_n)
  \]
\end{lemma}
\begin{proof}
  \begin{align*}
    \Bang^n(a_{1+n})
      &= a_n \\
      &= \Var{ys}(n)_n \\
      &= x_n \\
      &= \Bang^n(x_{1+n}) \\
      &= \Bang^n(\Var{ys}(1+n)_{1+n}) \\
      &= \Bang^n(b_{1+n}) \\
      &= b_n
  \end{align*}
\end{proof}

\begin{lemma}\label{lem:InjPresImpliesComplete}
  If $\Op{pres}$ is injective, then $L_{\FMSet}$ is complete.
\end{lemma}
\begin{proof}
  Given a limit $\ell : L_{\FMSet}$\todo{We're implicitly working with the HIT-definition here},
  denote by $\ell_n : L_{\FMSet} → \FMSet^n 1$ the projection maps out of the limit.

  Assume $x, y_1, y_2 : L_{\FMSet}$, $\Var{ys} : ℕ → L_{\FMSet}$,
  $\Op{split} : ∀ n\Where (\Var{ys}_n = y_1) \mathrel{+} (\Var{ys}_n = y_2)$
  and $\Op{diag} : ∀ n\Where x_n = \Var{ys}_n(n)$.
  The goal is to show $\PropTruncCon[x = y_1 \mathrel{+} x = y_2]$.
  From $\Op{split}$ we define the complement of $\Var{ys}$,
  \[
    \bar{\Var{ys}}(n)\DefEq
      \begin{cases}
        y_2 & \text{if}~\Var{ys}_n(n) = y_1 \\
        y_1 & \text{if}~\Var{ys}_n(n) = y_2 \\
      \end{cases}
  \]
  We show that the diagonal of $\bar{\Var{ys}}$ too has the limit-property,
  i.e.\@ that
  \[
    ∀ n\Where
      \Bang^n (\bar{\Var{vs}}(1+n)_{1+n}) = \bar{\Var{ys}}(n)_n
      \Step{step:IsLimYsComplement}
  \]
  For this, fix $n$ and check the four cases generated by inspecting $\Op{split} n$
  and $\Op{split}{} (1+n)$.
  In one case, \cref{step:IsLimYsComplement} reduces to the limit-property of $y_1$,
  in another to that of $y_2$ and in the remaining cases to \cref{lem:DiagLimCaseAnalysis}.
  Call the resulting limit $\bar{x} : L_{\FMSet}$.

  Write $\BagCon{x, y} \DefEq \eta\, x \oplus \eta\, y : \FMSet X$.
  Then for all $n$, we know that
  \begin{align}\Step{step:ppc}
    \BagCon{\Var{ys}_n, \bar{\Var{ys}}_n} = \BagCon{y_1, y_2}
  \end{align}
  either by $\Op{refl}$ or $\Op{\oplus comm}$, depending on $\Op{split} n$.
  Then\todo{better wording}
  \[
    \Op{pres} \BagCon{x, \bar{x}}\, n
      = \BagCon{x_n , \bar{x}_n}
      = \BagCon{\Var{ys}(n)_n , \bar{\Var{ys}}(n)_n}
      = \Op{pres} \BagCon{\Var{ys}(n) , \bar{\Var{ys}}(n)}\, n
      = \Op{pres} \BagCon{y_1 , y_2}\, n
  \]
  Therefore, $\Op{pres}(\BagCon{x, \bar{x}}) = \Op{pres}(\BagCon{y_1, y_2})$.
  From injectivity of $\Op{pres}$ it follows that
  \[
    x \in \BagCon{x, \bar{x}} = \BagCon{y_1, y_2}
  \]
  which means that merely $x = y_1$ or $x = y_2$.
\end{proof}

\begin{lemma}\label{lem:LLPOImpliesPresInj}
  Assuming \LLPO, $\Op{pres}$ is injective.
\end{lemma}
\begin{proof}
  \todo[inline]{Prove it.}
\end{proof}

\subsection{Final Coalgebras as an $\omega$-Limit in Groupoids}\label{ssec:FMGpdLim}

\begin{theorem}\label{thm:FMGpdLim}
  Let $L_{\Bag} \DefEq \lim_{n < \omega} \Bag^n 1$.
  The limit-preservation map $\operatorname{pres}$ is an equivalence of groupoids.
  In particular, the limit $L_{\Bag}$ is a fixpoint of $\Bag$ and its final coalgebra.
\end{theorem}

\subsection{Truncating the Groupoid Construction}

Compare the set-truncation of the groupoid construction
and the set-level definition.

\begin{theorem}\label{thm:FMSetFixpointOfTrunc}
  The set-truncation of $\Lim{\Bag}$ is a fixpoint of $\FMSet$, i.e.\@
  there is an equivalence $\FMSet \SetTrunc{\Lim{\Bag}} ≃ \SetTrunc{\Lim{\Bag}}$.
\end{theorem}
\begin{proof}
  The equivalence is obtained from the composition
  \begin{align}
    \FMSet \SetTrunc{\Lim{\Bag}}
      &≃ \FMSet \Lim{\Bag}          \Step{thm:FMSetFixpointOfTrunc:step1} \\
      &≃ \SetTrunc{\Bag \Lim{\Bag}} \Step{thm:FMSetFixpointOfTrunc:step2} \\
      &≃ \SetTrunc{\Lim{\Bag}}      \Step{thm:FMSetFixpointOfTrunc:step3}
  \end{align}
  where \eqref{thm:FMSetFixpointOfTrunc:step1} is invariance of $\FMSet$ under set-truncation
  (\cref{thm:FMSetSetTruncInvariant}),
  \cref{thm:FMSetFixpointOfTrunc:step2} is \cref{thm:FMSetOfFMGpdTrunc}
  and \eqref{thm:FMSetFixpointOfTrunc:step3} follows since $\Lim{\Bag}$ is a limit (\cref{thm:FMGpdLim}).
\end{proof}

Note that the above fixpoint is not necessarily the \emph{largest} fixpoint.
\todo[inline,caption={Choice for largest fixpoint}]{%
  \emph{(Unproven)}
  Only assuming the (full) axiom of choice this is the case, i.e.\@ yields a final coalgebra.
  }

\section{Discussion: Alternatives}
\subsection{Outlook: Generalization to Analytic Functors}

\begin{itemize}
    \item Hint at a definition of analytic functors using
        the above definitions (pick a subgroupoid of Bij etc.)
    \item Question:
        Does this definition \emph{weakly preserve pullbacks}?
        This would be the classical definition.
\end{itemize}

\subsection{Using Coinductive Types?}

\begin{itemize}
    \item It is not clear that Agda's coinductive types
        interacts well with HITs.
    \item This might not work with the groupoid-definition:
        Either we use HITs (possibly inconsistent, for the small Bij),
        or the construction ends up being too large.
    \item
        Another approach: Quotient the (entire) final coalgebra of lists.
\end{itemize}

\section{Conclusions}

\subsubsection{Acknowledgements}

%\nocite{*}

\bibliographystyle{splncs04}
\bibliography{Multiset}
\end{document}
